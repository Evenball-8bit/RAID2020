;*************** ROM PAGE 2 SUBROUTINES AND DATA AREA ************
;
;THIS ASSEMBLY IS USED WHEN 2 ROM PAGES OF 32K EACH ARE TO BE USED.
;THIS SECOND PAGE IS ASSEMBLED AS AN INCLUDE THAT USES THE ASSEMBLER'S
;.SEGMENT COMMAND.  IT IS USED TO HOLD BACKGROUND DATA ONLY.
;BACKGROUND DATA IS USED WITH THE ROUTINES INITBACK AND
;SCRLBACK.  THESE ROUTINES WILL AUTOMATICALLY TAKE CARE OF FETCHING
;BACKGROUND DATA FROM THIS SECOND PAGE WHEN USED ACCORDING TO THE FOLLOWING
;RULES:
;
;1. MAKE A COPY OF THIS FILE UNDER YOUR OWN NAME.  PUT AS MUCH BACKGROUND 
;   INFO AS CAN FIT FROM THE ORG AT H'8000 TO THE ORG AT H'FC00.  DO NOT 
;   PUT ANY TYPE OF DATA OTHER THAN BACKGROUND DATA UNLESS IT WILL BE USED 
;   BY ROUTINES OF YOUR OWN.  YOU CAN CHECK HOW MUCH ROOM YOU HAVE USED
;   BY LOOKING AT THE .LST OUTPUT AND FINDING THE START OF THIS ASSEMBLY.
;   TRACE THAT UNTIL YOU FIND THE .ORG H'FC00 AND MAKE SURE YOUR CODE
;   DID NOT OVERFLOW INTO THIS AREA.  YOU CAN ESTIMATE BY MULTIPLYING
;   EACH BACKGROUND'S HEIGHT BY ITS WIDTH AND ADDING 1/16 MORE FOR PALETTE.
;
;2. REMOVE THE COMMENT FROM THE INCLUDE OF THIS FILE AT THE TOP OF YOUR 
;   COPY OF USERASM.ASM.   THE STATEMENT FROM WHICH YOU SHOULD REMOVE THE
;   COMMENT SYMBOL (;) IS:       ;INCLUDE( MEMORY.ASM)
;
;3. ASSEMBLING WILL NOW PRODUCE 2 OUTPUT FILES INSTEAD OF 1.  THE ONE
;   TO LOAD INTO THE LOW 32K PAGE WILL NOW BE CALLED CODE.SEG.  THE ONE
;   CONTAINING YOUR BACKGROUND DATA WILL BE CALLED MEMORY.SEG.
;
;4. YOU MUST RENAME THESE TO CODE.OBJ AND MEMORY.OBJ BECAUSE NINLINK USES
;   AN EXTENSION OF .OBJ.
;
;5. WHEN YOU USE NINLINK, SPECIFY:   NINLINK CODE MEMORY
;   THE OUTPUT FILE WILL BE CODE.PRG.

;6. IF YOU ARE ONLY PUTTING BACKGROUND DATA HERE, YOU CAN SIMPLY PUT IT
;   INTO YOURBACK.ASM AND YOU DON'T HAVE TO MAKE ANOTHER COPY OF THIS FILE
;   WITH A NEW NAME SINCE YOURBACK.ASM IS INCLUDED HERE AND IS A DUMMY
;   FILE NAME.
.feature force_range
;Commented out by evenball
;DEFINE( PAGED,-1)	;SIGNAL THAT WE ARE PAGED.  SUBS USES THIS DEFINE.
 PAGED = -1			;Don't use defines in CA65
;.COMMAND -O			;ENABLE MULTIPLE OUTPUT FILES
;.SEGMENT .MEMORY,H'8000		;DEFINE SEGMENT .MEMORY, LOAD AT 8000H
;.segment "BANK_01"
;.MEMORY				;ACTIVATE SEGMENT .MEMORY

;THIS AREA IS DESIGNED TO EXACTLY MATCH AN AREA IN USERASM.ASM SO THAT
;WE CAN SUCCESSFULLY PAGE AND BOOT.  






;Commented out the orgs - Evenball

.segment "BANK_01"
.ORG	0		;DO NOT CHANGE THIS ORG

;INCLUDE( YOURBACK.ASM)	;HERE'S THE BEST WAY TO INCLUDE YOUR DATA, IN A FILE.
.include "YOURBACK.ASM"
;.ORG	$7BA0		;FINAL ORG FOR THE CODE TO ACCESS THE BACKGROUND INFO.

;More code that is from who knows where I'm just insterting as bytes to match the 
;retail ROM. - Evenball
.byte	$E2
.byte	$03, $69, $00, $8D, $E2, $03, $AD, $C6
.byte	$05, $20, $D8, $9D, $8D, $C6, $05, $20
.byte	$A9, $FB, $20, $C2, $EB, $AD, $18, $05
.byte	$C5, $B4, $F0, $0B, $B0, $05, $A5, $B4
.byte	$18, $69, $1F, $AA, $20, $86, $E1, $AE
.byte	$C6, $05, $F0, $05, $A0, $00, $20, $18
.byte	$DC, $AD, $09, $05, $10, $03, $20, $95
.byte	$D8, $AD, $8D, $03, $0D, $8E, $03, $29

;THIS ROUTINE IS USED TO CHECK OUT A ROW OF BACKGROUND INFO TO SEE IF
;IT IS CONSIDERED SOLID.  ON RETURN, CY MEANS SOLID AND A HAS THE VALUE.
;NC MEANS WE MADE IT THROUGH THE ROW LOOP WITHOUT FINDING SOLID.  THIS
;CODE IS A COPY OF A LOOP FROM SUBS.ASM, LOOK FOR CALL_CHK IN SUBS.ASM.

CKR:
;.EQU	CHK_ROW,(CKR+H'8000)
CHK_ROW = CKR+$8000
;CHK_ROW = CKR

C0:	LDA	(SUBSVAR1),Y		;GET A CHAR
	INY
	CMP	SUBSVAR5		;SOLID?
	BCS	C2			;SKIP IF SO.
	DEX
	BNE	C0
C2:	RTS
	
;THIS ROUTINE IS USED TO GET THE BACKGROUND'S WIDTH AND HEIGHT VALUES
;IF THE BACKGROUND IS IN THE SECOND PAGE.

GW:
;.EQU	GET_WIDE,(GW+H'8000)
GET_WIDE = GW+$8000
	;.byte	$AD, $03, $00	
        LDA	a:BACKBASE+1
	ORA	#$80		;TEMPORARILY TURN ON THE PAGE BIT
	STA	a:BACKBASE+1
	LDY	#0
	LDA	(BACKBASE),Y
	STA	BACKSIZE
	INY
	LDA	(BACKBASE),Y
	STA	BACKWIDE
	CLC
	ADC	#3		;ROUND WIDTH UP TO MAKE PALETTE WIDTH
	ROR	A
	LSR	A		;AND DIVIDE BY 4 TO GET PALETTE WIDTH
	STA	BPWIDE

	INY
	LDA	(BACKBASE),Y
	STA	BACKHIGH	;GET THE 3 BACKGROUND PARAMETERS
	LDA	a:BACKBASE+1
	AND	#$7F
	STA	a:BACKBASE+1	;REMOVE THE PAGE BIT AGAIN
	RTS

;THIS ROUTINE WILL MULTIPLY REGISTER X BY REGISTER Y AND STORE THE RESULT
;LOW BYTE IN X AND HIGH IN Y.  THIS ROUTINE MAY BE CALLED FROM
;ANY LEVEL AND IT USES ITS OWN VARIABLES.  THIS ROUTINE DOES NOT CHANGE
;MATH4.

MUL2: 
;.EQU	MULPNT,(MUL2+H'8000)
MULPNT = MUL2+$8000
	STY	MATH1		;SAVE MULTIPLIER
	STX	MATH3		;SAVE MULTIPLICAND
	LDA	#0
	STA	MATH2		;ZERO HIGH RESULT
	LDX	#8		;THERE ARE 8 BITS TO TEST FOR

MU10:	ASL	A		;SHIFT PRODUCT 1 TO DOUBLE IT.  FIRST LOOP=0
	ROL	MATH2		;AND MOVE BIT UP INTO RESULT HIGH BYTE

	ASL	MATH1		;SEE IF WE NEED TO ADD FOR THIS BIT
	BCC	MU20
	CLC
	ADC	MATH3		;IF SO, ADD IN THE VALUE
	BCC	MU20
	INC	MATH2		;IF CARRY, BRING UP TO HIGH RESULT
MU20:	DEX
	BNE	MU10
	TAX			;SAVE LOW BYTE IN RETURN REG	
	LDY	MATH2		;AND GET HIGH
	RTS

;THIS ROUTINE WILL ADD THE 1 BYTE VALUE IN A TO THE 2 BYTE VALUE IN
;X AND Y (X LOW BYTE).  THIS ROUTINE MAY BE CALLED FROM ANY LEVEL AND 
;IT USES ITS OWN VARIABLES.  ONLY MATH1 IS CHANGED.

ADD_WRD2:
;.EQU	ADDPNT,(ADD_WRD2+H'8000)
ADDPNT = ADD_WRD2+$8000

	STX	MATH1
	CLC
	ADC	MATH1
	TAX
	BCC	AAW10
	INY
AAW10:	RTS


;THIS ROUTINE WILL TAKE A VIRTUAL DATA ROW # WITHIN THE CURRENT BACKGROUND 
;IN Y AND A VIRTUAL STARTING DATA COLUMN # IN X AND WILL LOAD SCBUF WITH THE 
;DATA TO FILL THAT ROW ON SCREEN.  IT MAKES THE CORRECT INDEX INFO INTO
;THE VIRTUAL SCREEN AND ALSO PUTS THE CORRECT PALETTE DATA THERE TOO.
;OUR SCREEN WRAPS AROUND IN THE SAME MANNER FOR ALL BACKGROUNDS AND THUS
;THE X AND Y ROW ARE ALL THAT IS NEEDED TO DETERMINE WHERE THE DATA IS
;TO BE WRITTEN.

;THIS ROUTINE DOES NOT RANGE CHECK YOUR VALUES SO MAKE SURE THEY ARE OK.

;SCBUF MUST HAVE 53 BYTES OF AVAILABLE ROOM IF 1 BY 1 MODE.
;THIS ROUTINE WILL NOT CHECK THIS FOR YOU, YOU MUST MAKE SURE SCBUF
;CAN HOLD THE REQUIRED DATA.

BR2:
;.EQU	BLD_ROW2,(BR2+H'8000)

BLD_ROW2 = BR2+$8000

	STY	TMP_NMI7	;SAVE THE ROW AND COL WE ARE DOING
	STX	TMP_NMI8

	LDX	BACKWIDE
	JSR	MULPNT		;TO CALL THIS ROUTINE WE MUST ADD 8000H
	LDA	TMP_NMI8
	JSR	ADDPNT		;MAKE EXACT POINTER TO THE DATA
	TXA
	CLC
	ADC	a:BACKBASE
	STA	a:NMI_PTR
	TYA
	ADC	a:BACKBASE+1
	ORA	#$80		;ACCOUNT FOR SECOND PAGE
	STA	a:NMI_PTR+1	;POINT TO THE DATA WITH INDIRECT REG

;NMI_PTR POINTS TO DATA, TMP_NMI7 HAS DATA ROW, TMP_NMI8 HAS COL

	LDA	TMP_NMI7	;GET BACK ROW
	SEC
BLR10:	STA	TMP_NMI5	;SAVE VALUE BEFORE SUBTRACTING
	SBC	#30		;MOD IT BY THE ROW TO SEE WHERE IN SCREEN BUF
	BCS	BLR10		;GO TILL UNDERFLOW.  THEN TMP_NMI5 HAS MOD ROW

	LDA	TMP_NMI8
	AND	#$1F		;MAKE SCREEN COLUMN MOD WIDTH
	STA	TMP_NMI6	

;NOW TMP_NMI5 HAS STARTING ROW WITHIN SCREEN BUFFER AND TMP_NMI6 HAS COL

BLR15:	LDX	#$20		;ASSUME PAGE AT 2000H STARTS THE COLUMN
	
	LDA	#32
	AND	TMP_NMI8	;TEST TO GET PAGE NUMBER 
	BEQ	BLR20
	LDX	#$24		;IF ODD BIT ABOVE WIDTH, PAGE 2

BLR20:	STX	TMP_NMIA	;SAVE STARTING PAGE

;NOW TMP_NMIA HAS THE BASE PAGE HIGH BYTE

	LDX	TMP_NMI5	;GET BACK STARTING ROW
	LDY	#$20
	JSR	MULPNT		;MAKE BYTE OFFSET TO ROW START
	STX	TMP_NMID
	STY	TMP_NMIE	;SAVE OFFSET TO ROW START
	LDA	TMP_NMI6
	JSR	ADDPNT		;POINT TO SCREEN OFFSET
	STX	TMP_NMI2
	TYA
	CLC
	ADC	TMP_NMIA	;ADJUST HIGH BYTE FOR PAGE OFFSET IN VIDEO
	STA	TMP_NMI3	;SAVE AS POINTER

	LDA	TMP_NMIA	
	EOR	#4		;MAKE HIGH BYTE OF NEXT PAGE
	CLC
	ADC	TMP_NMIE	;MAKE HIGH BYTE OF NEXT PAGE ADJUSTED TO ROW
	STA	TMP_NMIE

;NOW TMP_NMI2 AND 3 POINT TO THE SCREEN POSITION TO WRITE DATA AT.  IF
;THE LINE GOES INTO THE NEXT PAGE, TMP_NMID AND E HAVE THE ADDRESS.
;LOAD THAT DATA INTO SCBUF BUT WE MAY NEED TO BREAK UP
;THE LINE (HALF GETS ADDRESSED INTO 1 PAGE AND THE OTHER HALF GOES TO
;THE NEXT PAGE.

	LDX	SCCNT		;GET THE INDEX
	LDA	TMP_NMI3
	STA	SCBUF,X
	INX
	LDA	TMP_NMI2
	STA	SCBUF,X
	INX

	LDA	#32
	SEC			;SCROLL SITUATIONS (SPANS 33 CHARS, NOT 32).
	SBC	TMP_NMI6	;MAKE WIDTH TO END OF THIS SCREEN
	STA	TMP_NMI1

;WE ALREADY QUED PLACE TO WRITE TO.  NEED TO QUE AMOUNT TO WRITE OUT

	LDA	TMP_NMI1
	STA	SCBUF,X
	INX

;NOW QUE THE FIRST HALF OF THE DATA.  ACTUALLY, IT MAY ALL BE ON THIS
;SCREEN IF THE COLUMN IS 0.

	LDY	#0
BLR40:	LDA	(NMI_PTR),Y	;GET A BYTE
	STA	SCBUF,X		;QUE IT UP
	INX
	INY
	DEC	TMP_NMI1
	BNE	BLR40		

;SEE IF WE NEED TO WRITE OUT ANOTHER LINE.

	LDA	BACKWIDE	;GET WIDTH IN SCREEN
	SEC
	SBC	TMP_NMI8	;MAKE WIDTH LEFT TO END OF SCREEN
	CMP	#32		;SEE IF EXACTLY AT END
	BEQ	BLR42
	INC	TMP_NMI1	;IF NOT, ALWAYS WRITE OUT EXTRA COL
BLR42:	LDA	TMP_NMI6	;GET BACK COLUMN WITHIN SCREEN. 
	CLC
	ADC	TMP_NMI1	;ADD IN POSSIBLE EXTRA COLUMN
	STA	TMP_NMI1	;SAVE LENGTH TO WRITE
	BEQ	BLR200		;IF NONE TO WRITE OUT, DON'T NEED THIS WRITE
	
	LDA	TMP_NMIE	;IF NEED SECOND WRITE, THIS HAS ADDRESS
	STA	SCBUF,X
	INX
	LDA	TMP_NMID
	STA	SCBUF,X
	INX
	LDA	TMP_NMI1	;AND THIS HAS LENGTH
	STA	SCBUF,X
	INX

BLR60:	LDA	(NMI_PTR),Y	;GET A BYTE
	STA	SCBUF,X		;QUE IT UP
	INX
	INY
	DEC	TMP_NMI1
	BNE	BLR60		

;DONE QUEING DATA.  QUE THE PALETTE INFO

BLR200: STX	SCCNT		;SAVE OFFSET IN BUFFER
	LDA	TMP_NMI7	;GET ROW WITHIN ACTUAL SCREEN
	LSR	A
	LSR	A		;MAKE PALETTE ROW WE ARE ON
	TAY
	LDX	BPWIDE		;AND GET WIDTH OF PALETTE INFO
	JSR	MULPNT		
	LDA	TMP_NMI8	;GET COL WE ARE ON
	LSR	A
	LSR	A		;MAKE PALETTE BYTE IN THAT COLUMN WE ARE ON
	JSR	ADDPNT		;MAKE EXACT POINTER TO THE DATA
	TXA
	CLC
	ADC	BPBASE
	STA	a:NMI_PTR
	TYA
	ADC	BPBASE+1
	ORA	#$80		;ACCOUNT FOR SECOND PAGE
	STA	a:NMI_PTR+1	;POINT TO THE DATA WITH INDIRECT REG

;NMI_PTR POINTS TO PAL DATA WE ARE TO USE.  MAKE POINTERS TO THE
;PALETTE BYTE IN THE PALETTE RAM.

	LDA	TMP_NMI5	;GET BACK ROW WITHIN SCREEN
	LSR	A
	LSR	A
	STA	TMP_NMIB

	LDA	TMP_NMI6	;GET BACK COL WITHIN SCREEN
	LSR	A
	LSR	A		;AND MAKE INTO PALETTE BYTE
	STA	TMP_NMIC

;NOW TMP_NMIB HAS STARTING ROW WITHIN PALETTE BUFFER AND TMP_NMIC HAS BYTE

BLR215:	LDX	#$23		;ASSUME PAGE 1 PALETTE ADDRESS
	
	LDA	#32
	AND	TMP_NMI8	;TEST TO GET PAGE NUMBER 
	BEQ	BLR220
	LDX	#$27		;IF ODD BIT ABOVE WIDTH, PAGE 2

BLR220:	STX	TMP_NMIA	;SAVE STARTING PAGE

;NOW TMP_NMIA HAS THE BASE PAGE HIGH BYTE

	LDX	TMP_NMIB	;GET BACK STARTING ROW
	LDY	#8
	JSR	MULPNT		;MAKE BYTE OFFSET TO ROW START
	STX	TMP_NMI3
	STY	TMP_NMI4	;SAVE COPY FOR NEXT PAGE POSSIBILITY
	LDA	TMP_NMIC
	JSR	ADDPNT		;POINT TO SCREEN OFFSET
	TXA
	CLC
	ADC	#$C0		;LOW BYTE OF OFFSET IS C0
	STA	TMP_NMI1
	TYA
	ADC	TMP_NMIA	;ADJUST HIGH BYTE FOR PAGE OFFSET IN VIDEO
	STA	TMP_NMI2	;SAVE AS POINTER

	LDA	TMP_NMI3	;GET BACK SECOND PAGE POINTER
	CLC
	ADC	#$C0		;AND ADD THE START OF PAL RAM TOO
	STA	TMP_NMI3
	LDA	TMP_NMIA
	EOR	#4		;MAKE HIGH BYTE OF NEXT PAGE
	ADC	TMP_NMI4	;ADD IN HIGH BYTE OF OFFSET
	STA	TMP_NMI4

;NOW TMP_NMI1 AND 2 POINT TO THE SCREEN POSITION TO WRITE DATA AT.  IF
;THE LINE GOES INTO THE NEXT PAGE, TMP_NMI3 AND TMP_NMI4 HAVE THE LOCATION
;TO WRITE TO.  NOW LOAD THE PAL INTO SCBUF BUT WE MAY NEED TO BREAK UP
;THE LINE (HALF GETS ADDRESSED INTO 1 PAGE AND THE OTHER HALF GOES TO
;THE NEXT PAGE).

	LDX	SCCNT		;GET THE INDEX
	LDA	TMP_NMI2
	STA	SCBUF,X
	INX
	LDA	TMP_NMI1
	STA	SCBUF,X
	INX

	LDA	TMP_NMI6	;GET COL WITHIN THIS SCREEN
	TAY			;SAVE A COPY
	LSR	A
	LSR	A		;MAKE COLUMN TO START ON
	STA	TMP_NMI6

	LDA	BPWIDE		;GET SCREEN PALETTE WIDTH
	SEC
	SBC	TMP_NMIC	;MAKE PALETTE WIDTH TO END OF SCREEN
	CMP	#9		;SEE IF HAVE AT LEAST 9 LEFT TO WRITE OUT
	BCC	BLR225		;IF NOT, WRITE WHAT WE CAN
      	LDA	#9		;IF SO, SET TO WRITE 9 FOR ODD PIX ALIGNMENT

BLR225:	TAY			;SAVE WIDTH LEFT TO END OF BACKGROUND
	LDA	#8		
	SEC
	SBC	TMP_NMI6	;MAKE WIDTH TO END OF THIS PAGE
	STA	TMP_NMI1
	TYA			;GET WIDTH TO END OF PAL DATA OR 9 IF TOO BIG
	SEC
	SBC	TMP_NMI1	;MAKE AMOUNT FOR NEXT LINE
	STA	TMP_NMI6

;WE ALREADY QUED PLACE TO WRITE TO.  NEED TO QUE AMOUNT TO WRITE OUT.
;TMP_NMI1 HAS THAT.  TMP_NMI6 HAS AMOUNT FOR NEXT PAGE.

BLR230:	LDA	TMP_NMI1
	STA	SCBUF,X
	INX

;NOW QUE THE FIRST HALF OF THE DATA.  ACTUALLY, IT MAY ALL BE ON THIS
;SCREEN IF THE COLUMN IS 0.

	LDY	#0
BLR240:	LDA	(NMI_PTR),Y	;GET A BYTE
	STA	SCBUF,X		;QUE IT UP
	INX
	INY
	DEC	TMP_NMI1
	BNE	BLR240		

;SEE IF WE NEED TO WRITE OUT ANOTHER PAL ROW

	LDA	TMP_NMI6	;GET BACK COLUMN WITHIN SCREEN. 
	BEQ	BLR280		;ITS THE AMOUNT WE NEED ON SECOND SCREEN

	LDA	TMP_NMI4	;IF NEED SECOND WRITE, THIS HAS ADDRESS
	STA	SCBUF,X
	INX
	LDA	TMP_NMI3
	STA	SCBUF,X
	INX
	LDA	TMP_NMI6	;AND THIS HAS LENGTH
	STA	SCBUF,X
	INX

BLR260:	LDA	(NMI_PTR),Y	;GET A BYTE
	STA	SCBUF,X		;QUE IT UP
	INX
	INY
	DEC	TMP_NMI6
	BNE	BLR260		

BLR280:	STX	SCCNT		;UPDATE COUNT IN BUFFER.

;ALL DONE.  

BLR300:	RTS

;THIS ROUTINE WILL TAKE A VIRTUAL DATA ROW # WITHIN THE CURRENT BACKGROUND 
;IN Y AND A VIRTUAL STARTING DATA COLUMN # IN X AND WILL LOAD SCBUF WITH THE 
;DATA TO FILL THAT COLUMN ON SCREEN.  IT MAKES THE CORRECT INDEX INFO INTO
;THE VIRTUAL SCREEN AND ALSO PUTS THE CORRECT PALETTE DATA THERE TOO.
;OUR SCREEN WRAPS AROUND IN THE SAME MANNER FOR ALL BACKGROUNDS AND THUS
;THE X AND Y ROW ARE ALL THAT IS NEEDED TO DETERMINE WHERE THE DATA IS
;TO BE WRITTEN.

;THIS ROUTINE DOES NOT RANGE CHECK YOUR VALUES SO MAKE SURE THEY ARE OK.

;SCBUF MUST HAVE 69 BYTES OF AVAILABLE ROOM IN THE SCREEN BUFFER.
;THIS ROUTINE WILL NOT CHECK THIS FOR YOU.

BC2:
;.EQU	BLD_COL2,(BC2+H'8000)
BLD_COL2 = BC2+$8000

	STX	TMP_NMI8	;$FDE8 in compiled rom
	STY	TMP_NMI7	;SAVE THE ROW AND COL WE ARE DOING

	LDX	BACKWIDE
	JSR	MULPNT		
	LDA	TMP_NMI8
	JSR	ADDPNT		;MAKE EXACT POINTER TO THE DATA
	TXA
	CLC
	ADC	a:BACKBASE
	STA	a:NMI_PTR
	TYA
	ADC	a:BACKBASE+1
	ORA	#$80		;ACCOUNT FOR SECOND PAGE
	STA	a:NMI_PTR+1	;POINT TO THE DATA WITH INDIRECT REG

;NMI_PTR POINTS TO DATA, TMP_NMI7 HAS DATA ROW, TMP_NMI8 HAS COL

	LDA	TMP_NMI7	;GET BACK ROW
	SEC
BLC10:	STA	TMP_NMI5	;SAVE VALUE BEFORE SUBTRACTING
	SBC	#30		;MOD IT BY THE ROW TO SEE WHERE IN SCREEN BUF
	BCS	BLC10		;GO TILL UNDERFLOW.  THEN TMP_NMI5 HAS MOD ROW

	LDA	TMP_NMI8
	AND	#$1F		;MAKE SCREEN COLUMN MOD WIDTH
	STA	TMP_NMI6	

;NOW TMP_NMI5 HAS STARTING ROW WITHIN SCREEN BUFFER AND TMP_NMI6 HAS COL

BLC15:	LDX	#$20		;ASSUME PAGE AT 2000H STARTS THE COLUMN
	
	LDA	#32
	AND	TMP_NMI8	;TEST TO GET PAGE NUMBER 
	BEQ	BLC20
	LDX	#$24		;IF ODD BIT ABOVE WIDTH, PAGE 2

BLC20:	STX	TMP_NMIA	;SAVE STARTING PAGE

;NOW TMP_NMIA HAS THE BASE PAGE HIGH BYTE

	LDX	TMP_NMI5	;GET BACK STARTING ROW
	LDY	#$20
	JSR	MULPNT		;MAKE BYTE OFFSET TO ROW START
	LDA	TMP_NMI6
	JSR	ADDPNT		;POINT TO SCREEN OFFSET
	STX	TMP_NMI2
	TYA
	CLC
	ADC	TMP_NMIA	;ADJUST HIGH BYTE FOR PAGE OFFSET IN VIDEO
	STA	TMP_NMI3	;SAVE AS POINTER

;NOW TMP_NMI2 AND 3 POINT TO THE SCREEN POSITION TO WRITE DATA AT.  IF
;THE LINE GOES INTO THE NEXT PAGE, TMP_NMI6 HAS THE COLUMN TO START AT AND
;TMP_NMIA IS THE PAGE (SAME PAGE). LOAD THE DATA INTO SCBUF BUT WE MAY 
;NEED TO BREAK UP THE LINE (HALF GETS ADDRESSED INTO 1 PAGE AND THE 
;OTHER HALF GOES TO THE NEXT PAGE.

	LDX	SCCNT		;GET THE INDEX
	LDA	TMP_NMI3
	ORA	#$80		;SET VERTICAL WRITE BIT
	STA	SCBUF,X
	INX
	LDA	TMP_NMI2
	STA	SCBUF,X
	INX

	LDA	#30		;GET MAX HEIGHT WE CAN WRITE
	CMP	BACKHIGH	;SEE IF THERE REALLY IS THAT MUCH
	BCC	BLC30
     	LDA	BACKHIGH	;IF NOT, WRITE OUT MAX
BLC30:	SEC
	SBC	TMP_NMI5	;MAKE HEIGHT TO BOTTOM OF THIS SCREEN
	STA	TMP_NMI1

;WE ALREADY QUED PLACE TO WRITE TO.  NEED TO QUE AMOUNT TO WRITE OUT

	STA	SCBUF,X
	INX

;NOW QUE THE FIRST HALF OF THE DATA.  ACTUALLY, IT MAY ALL BE ON THIS
;SCREEN IF THE ROW IS 0.

	LDY	#0
	CLC
        
        ;$FE70 in ROM - Evenball
BLC40:	LDA	(NMI_PTR),Y	;GET A BYTE
	STA	SCBUF,X		;QUE IT UP
	INX			;SKIP IN SCREEN BUFFER
	TYA
	ADC	BACKWIDE	;SKIP TO NEXT ROW IN DATA
	TAY
	BCC	BLC45
	INC	a:NMI_PTR+1
	CLC
BLC45:	DEC	TMP_NMI1
	BNE	BLC40		

;SEE IF WE NEED TO WRITE OUT ANOTHER LINE.

	LDA	TMP_NMI5	;GET BACK ROW WITHIN SCREEN. 
	BEQ	BLC200		;ITS THE AMOUNT WE NEED ON SECOND SCREEN

	LDA	TMP_NMIA	;IF NEED SECOND WRITE, START AT SCREEN TOP
	ORA	#$80		;OF SAME PAGE
	STA	SCBUF,X
	INX
	LDA	TMP_NMI6	;GET COLUMN WITHIN THAT ROW
	STA	SCBUF,X
	INX
	LDA	TMP_NMI5	;AND THIS HAS LENGTH
	STA	SCBUF,X
	INX
	STA	TMP_NMI1	;PUT BACK FOR LOOP COUNTER

	CLC
        
BLC60:	LDA	(NMI_PTR),Y	;GET A BYTE ***8$FEA5***
	STA	SCBUF,X		;QUE IT UP
	INX
	TYA
	ADC	BACKWIDE	;SKIP TO NEXT ROW IN DATA
	TAY
	BCC	BLC65
	INC	a:NMI_PTR+1
	CLC
BLC65:	DEC	TMP_NMI1
	BNE	BLC60		

;DONE QUEING DATA.  QUE THE PALETTE INFO

BLC200: STX	SCCNT		;SAVE OFFSET IN BUFFER
	LDA	TMP_NMI7	;GET ROW WITHIN ACTUAL SCREEN
	LSR	A
	LSR	A		;MAKE PALETTE ROW WE ARE ON
	TAY
	LDX	BPWIDE		;AND GET WIDTH OF PALETTE INFO
	JSR	MULPNT		
	LDA	TMP_NMI8	;GET COL WE ARE ON
	LSR	A
	LSR	A		;MAKE PALETTE BYTE IN THAT COLUMN WE ARE ON
	JSR	ADDPNT		;MAKE EXACT POINTER TO THE DATA
	TXA
	CLC
	ADC	BPBASE
	STA	a:NMI_PTR
	TYA
	ADC	BPBASE+1
	ORA	#$80		;ACCOUNT FOR SECOND PAGE
	STA	a:NMI_PTR+1	;POINT TO THE DATA WITH INDIRECT REG

;NMI_PTR POINTS TO PAL DATA WE ARE TO USE.  MAKE POINTERS TO THE
;PALETTE BYTE IN THE PALETTE RAM.

	LDA	TMP_NMI5	;GET BACK ROW WITHIN SCREEN
	LSR	A
	LSR	A
	STA	TMP_NMIB

	LDA	TMP_NMI6	;GET BACK COL WITHIN SCREEN
	LSR	A
	LSR	A		;AND MAKE INTO PALETTE BYTE
	STA	TMP_NMIC

;NOW TMP_NMIB HAS STARTING ROW WITHIN PALETTE BUFFER AND TMP_NMIC HAS BYTE

BLC215:	LDX	#$23		;ASSUME PAGE 1 PALETTE ADDRESS
	
	LDA	#32
	AND	TMP_NMI8	;TEST TO GET PAGE NUMBER 
	BEQ	BLC220
	LDX	#$27		;IF ODD BIT ABOVE WIDTH, PAGE 2

BLC220:	STX	TMP_NMIA	;SAVE STARTING PAGE

;NOW TMP_NMIA HAS THE BASE PAGE HIGH BYTE

	LDX	TMP_NMIB	;GET BACK STARTING ROW
	LDY	#8
	JSR	MULPNT		;MAKE BYTE OFFSET TO ROW START
	STX	TMP_NMI3
	STY	TMP_NMI4	;SAVE COPY FOR NEXT PAGE POSSIBILITY
	LDA	TMP_NMIC
	JSR	ADDPNT		;POINT TO SCREEN OFFSET
	TXA
	CLC
	ADC	#$C0		;LOW BYTE OF OFFSET IS C0
	STA	TMP_NMI1
	TYA
	ADC	TMP_NMIA	;ADJUST HIGH BYTE FOR PAGE OFFSET IN VIDEO
	STA	TMP_NMI2	;SAVE AS POINTER

;NOW TMP_NMI1 AND 2 POINT TO THE PAL RAM POSITION TO WRITE DATA AT.  
;NOW LOAD THE PAL INTO SCBUF BUT WE NEED TO BREAK UP DATA INTO INDIVIDUAL
;BYTES EACH ADDRESSED SEPERATELY.

	LDA	BACKHIGH
	CLC
	ADC	#3		;ROUND UP HEIGHT IN ROWS
	LSR	A
	LSR	A		;MAKE HEIGHT IN PALETTE BYTES
	STA	TMP_NMI3	;SAVE HERE	
	LDA	#8		;GET HEIGHT IF FULL SCREEN.
	CMP	TMP_NMI3	;SEE IF WE CAN DO IT
	BCC	BLC225		;IF THERE ARE ENOUGH, OK
	LDA	TMP_NMI3
BLC225:	STA	TMP_NMI3
	LDX	SCCNT		;GET THE INDEX
	LDY	#0		;ZERO INDEX WITHIN PALLETE RAM.

;START OF LOOP TO INDIVIDUALLY ADDRESS AND WRITE UP TO 8 PALETTE BYTES.

BLC230:	LDA	TMP_NMI2
	STA	SCBUF,X
	INX
	LDA	TMP_NMI1
	STA	SCBUF,X
	INX
	LDA	#1		;WE ALWAYS JUST QUE 1 IN THIS CASE
	STA	SCBUF,X
	INX

	LDA	(NMI_PTR),Y	;GET THE BYTE
	STA	SCBUF,X		;QUE IT UP
	INX
	TYA
	CLC
	ADC	BPWIDE		;UPDATE INDEX WITHIN OUR DATA
	TAY
	BCC	BLC240
	INC	a:NMI_PTR+1

;WRAP THE PALETTE RAM INDEX.  WE JUST NEED TO WRAP AROUND IN THIS BUFFER.

BLC240:	LDA	TMP_NMI1
	CLC
	ADC	#8		;SKIP TO NEXT PALETTE ROW
	ORA	#$C0		;BUT IF GOES PAST 0, MOVE BACK TO START
	STA	TMP_NMI1

	DEC	TMP_NMI3
	BNE	BLC230		

	STX	SCCNT		;UPDATE COUNT IN BUFFER

;ALL DONE. 

BLC300: RTS
.byte	0, 0, 0, 0, 0, 0

.ORG	$FF70 		;THIS ORG HOLDS WORST CASE WHEN PAGED ROM
;IFDEF:( `PAGED', `	;THIS IFDEF NOT NEEDED HERE BUT INCLUDED JUST
			;TO MATCH USERASM FOR DOCUMENTATION PURPOSES.
.ifdef PAGED
;THIS CODE IS USED TO CALL THE ROUTINE BLD_ROW2 WHICH IS A SUBSTITUTE FOR
;THE ROUTINE BUILD_ROW AND IS USED IF THE OFFSET OF A BACKGROUND IS
;<8000H.  IT HAS A MATCHING CALL IN USERASM IF THIS MODULE IS INCLUDED.

;CALL_ROW2:
	LDA	ROMPAGE
	ORA	#1
	JSR	SELPAGE 
	JSR	BLD_ROW2
	LDA	ROMPAGE
	JSR	SELPAGE 
	RTS	

;THIS CODE IS USED TO CALL THE ROUTINE BLD_ROW2 WHICH IS A SUBSTITUTE FOR
;THE ROUTINE BUILD_ROW AND IS USED IF THE OFFSET OF A BACKGROUND IS
;<8000H.  IT HAS A MATCHING CALL IN USERASM IF THIS MODULE IS INCLUDED.

;CALL_COL2:
	LDA	ROMPAGE
	ORA	#1
	JSR	SELPAGE 
	JSR	BLD_COL2
	LDA	ROMPAGE
	JSR	SELPAGE 
	RTS	

;THIS ROUTINE IS USED TO CALL THE ROUTINE GET_WIDE.

;CALL_GETWIDE:
	LDA	ROMPAGE
	ORA	#1
	JSR	SELPAGE
	JSR	GET_WIDE
	LDA	ROMPAGE
	JSR	SELPAGE
	RTS	

;THIS ROUTINE WILL CALL CHK_ROW FROM ANY PAGE.

;CALL_CHK:
	LDA	ROMPAGE
	ORA	#1
	JSR	SELPAGE 
	JSR	CHK_ROW
	PHP
	PHA
	LDA	ROMPAGE
	JSR	SELPAGE 
	PLA
	PLP
	RTS	
.endif
	

;IFDEF( `ROMVER', `		;THIS CODE USED WHEN ROM VERSION
.ifdef ROMVER

;ENTER HERE WITH THE DESIRED PAGE COMBO IN A.  HIGH NIBBLE HAS VIDEO
;PAGE AND LOW BIT HAS ROM PAGE.  A IS CHANGED, DONT COUNT ON ITS VALUE.
;THE BITS USED BY THE PAGE CIRCUIT MUST NOT BE ON.  AT THE CURRENT TIME
;THEY ARE BITS 08 AND 04.  THIS ROUTINE ASSUMES A 512 x 512 MAX CARTRIDGE.

;THE TABLE IS NEEDED BECAUSE OUR ROM CARTRIDGE DOES NOT DECODE THE ROM AREA.
;ANY WRITE TO ROM TRIGGERS THE LS377 PAGING PORT.  SINCE A WRITE ALSO 
;TRIGGERS A ROM READ (WR DOES NOT QUALIFY ROM) WE NEED TO WRITE TO AN AREA
;OF ROM THAT RETURNS THE SAME VALUE WE ARE WRITING.

;THIS ROUTINE MUST SAVE THE X AND Y REGISTERS.

SELPAGE_02:			;DONT LABEL HERE CAUSE ITS LABELED IN USERASM
	STX	PAGETEMP	;SAVE USERS VALUE FOR X
	PHA			;SAVE VALUE TO WRITE OUT
	AND	#3		;SAVE ROM PAGE BITS
	STA	WORKINGPAGE	
	PLA
	PHA			;MAKE ANOTHER COPY, GET ONE BACK
	LSR	A
	LSR	A
	LSR	A		;MOVE HIGH BITS DOWN TO ADD IN LOWEST.
	ORA	WORKINGPAGE
	TAX			;MAKE IT INTO AN INDEX
	PLA			;GET ORIGINAL VALUE
	ORA	#12		;PUT IN THE KEY CIRCUIT BITS
	STA	PAGETAB,X	;AND SET OUT WITH THE USERS BITS
	LDX	PAGETEMP
	RTS

;PAGETAB:
.byte 12,13
.byte 28,29
.byte 44,45
.byte 60,61
.byte 76,77
.byte 92,93
.byte 108,109
.byte 124,125
.endif
;	', `			;THIS CODE USED WHEN NOT ROM VERSION.
.IFNDEF ROMVER			;THIS CODE USED WHEN NOT ROM VERSION.
;ENTER HERE WITH THE DESIRED PAGE COMBO IN A.  HIGH NIBBLE HAS VIDEO
;PAGE AND LOW HAS ROM PAGE.

SELPAGE:	
	STA	253
	RTS
;	')
.endif

;THIS BOOT VECTOR IS NEEDED TO INSURE THAT WE DON'T CRASH IF WE 
;HAVE A PAGED VERSION.

PBOOT_02: 				;THIS LABEL ONLY FOR REFERENCE
	LDX	#$FF
	TXS			;SET UP THE STACK
	LDA	#0
	JSR	SELPAGE_02
	JMP	BOOT
;.ORG	H'7FFA
.segment "VECTORS2"
;HERE ARE THE INTERRUPT AND BOOT VECTORS.  

	.word	NMI		;NMI INTERRUPT (VERTICAL RETRACE INT)
	.word	PBOOT_02	;BOOT VECTOR
	.word	PBOOT_02	;IRQ VECTOR