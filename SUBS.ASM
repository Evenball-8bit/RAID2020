;
;THIS ASSEMBLY CONTAINS LOW LEVEL SUBROUTINES THAT CORRESPOND TO THE 
;DOCUMENT SUBS.DOC AS PUBLISHED BY COLOR DREAMS INC.  THIS ASSEMBLY
;IS COPYRIGHTED 1989 BY COLOR DREAMS INC., ALL RIGHTS RESERVED.
;
;TO USE THIS ASSEMBLY, COPY THE OVERLAY FILE USERASM.ASM TO THE FILE
;NAME YOU WISH TO USE FOR YOUR ASSEMBLY.  THEN SET THE ORIGIN IN THAT
;FILE AND PUT YOUR CODE INTO THE 3 LEGAL SUBROUTINE AREAS.  THE 3 AREAS 
;ALLOW BOOT UP INITILIZATION, NON-NMI PROCESSING, AND END OF NMI 
;INTERRUPT PROCESSING.

;DO NOT PUT ANY CODE AT ANY OTHER LOCATION OR YOU MAY FIND IT VERY 
;DIFFICULT TO UPDATE YOUR PROGRAM WHEN A NEW VERSION OF THIS MODULE
;COMES OUT.  THE MODULE USERASM.ASM "INCLUDE"S THIS MODULE (SUBS.ASM)
;AND YOU NEED ONLY COPY NEW VERSIONS OF THIS MODULE IN ORDER TO TAKE
;ADVANTAGE OF A NEW ENHANCEMENT (REFER TO SUBS.DOC FOR MORE INFO).

;WHEN GETTING A NEW VERSION, CHECK THE REVISION HISTORY TO MAKE SURE THAT
;CALLING CONVENTIONS HAVE NOT CHANGED FOR SUBROUTINES USED BY YOUR CODE.
;
;
; *********************** REVISION HISTORY  ****************************
;
;V 1.00 5/2/89.  
;THIS VERSION DOES NOT SUPPORT 2 BY 2 MODE BACKGROUNDS OR OBJECTS AND
;BACKGROUNDS MUST BE AT LEAST 32 WIDE AND AT LEAST 30 HIGH.

;V 1.10 5/10/89
;THIS VERSION DOES NOT SUPPORT 2 BY 2 MODE BACKGROUNDS OR OBJECTS.
;ALSO, CALLS TO THE CHARACTER SET SELECT AND ANIMATION/SPRITE INIT 
;ROUTINES SHOULD BE MADE ENTIRELY FROM EITHER THE NMI LEVEL OR FROM
;THE NON-NMI MAINLINE (EXCEPT FOR CALLS MADE AT BOOT).  IF LEVELS 
;ARE MIXED, THERE IS A SLIGHT CHANCE OF LOST SELECTIONS.
;BACKGROUND ANIMATION IS NOT SUPPORTED YET AND THERE IS NO SOUND OR
;GUN LOGIC.  VERTICAL SCROLLING GETS CONFUSED SOMETIMES BUT IS USABLE
;FOR DEBUGGING YOUR GAME.  HI-SCORE LOGIC IS UNTESTED.

;V 1.20 SAME AS 1.10 BUT BACKGROUND SCROLLING MUCH IMPROVED.  PAL DURING
;VERTICAL SCROLL STILL GETS STAGGERED.  ADDED BEEPA DEBUGGING ROUTINE.

;V 1.30 SOUND ADDED AND DEBUGGED.  STILL NEEDS DOTTED NOTES.  NO PUTOBJ, 
;AND ANIMATION FEATURES NEED IMPROVEMENT.  SEPERATED USER SUBS AREA
;INTO MODULE USERASM.ASM

;V 1.40.  EXTENSIVE SPRITE ROUTINES ADDED TO ALLOW COLLISION DETECTION AND
;ANIMATION CONTROL.  FIXED BUG IN SELSPSET THAT KILLED BACKGROUND SELECTION.

;V 1.50. ADDED TOP OF SCREEN STATUS BAR LOGIC.
;
;V1.60.  ADDED CONTINUATION ABILITY TO THE COLLISION DETECTION SO THAT
;MULTIPLE COLLISIONS COULD BE DETECTED.  GUN LOGIC INACTIVE AT THIS TIME.
;
;
;V1.70 GUN LOGIC INCLUDED BUT IT TAKES MORE MEMORY EVEN IF NOT USED.
;WILL TRY TO REMOVE IT BY USING "INCLUDE" BUT ASSEMBLER IS MAXED OUT 
;ON INCLUDES AND CRASHES.  NEW ABILITY TO "FLIP" A SPRITE FROM LEFT TO
;RIGHT HAS BEEN INCLUDED ALONG WITH THE ABILITY TO TURN IT UPSIDE DOWN.
;
;
;V1.80 GOT NEW ASSEMBLER AND MADE GUN LOGIC "INCLUDE".  ALSO ADDED AUTOKILL
;FUNCTION FOR SPRITE ANIMATIONS.  FIXED PUTOBJ BUG IN PAGE 2 (USED PAGE
;OFFSET OF 23).  ADDED "TTY" CALLS.

;V1.81.  FIXED GUN GETTING BAD Y LOCATION WITH GETSPRT IF SCANNING TARGETS.
;FIXED IMPROPER INIT OF SPRITE PALETTE REG 0 (IT OVERLAPS WITH BACKGROUND
;REG AND MUST NOT BE WRITTEN TO).

;V1.90   ADDED CODE TO TRIGGER AND DISABLE THE KEY CHIP CIRCUIT.  THIS 
;	REQUIRES ANOTHER 200 BYTES OF ROM IN EACH PAGE AND ANY NEW USER'S
;	WILL HAVE TO FREE THAT MUCH MEMORY.
;
;V1.91  ADDED PAGE 0 AND 1 CONTROL TO THE TTY ROUTINES.  MADE THE TTY
;	ROUTINES ADJUST FOR TOP OF SCREEN STATUS BAR.  FIXED SOME 
;	BAD RAM INIT VALUES AT BOOT ON SOME MACHINES.
;
;V1.92  SPEEDED UP THE GUN LOGIC AND ADDED VIDEOREQ BYTE TO ALLOW VIDEO
;	DISABLE AND ENABLE WITHOUT SCREEN WOBBLE.

;V1.93  ADDED CHANGEPAL AND SWAPSPRT.

;V1.94  REDUCED FLICKER OF SPRITES AND MADE MIRROR AND INVERT ALSO UPDATE
;	THE SPRITE BLOCK WITHOUT NEED TO CALL ANOTHER ROUTINE.

;V1.95  FIXED SPRITE FLICKER.  IT HAPPENED DUE TO TOP OF SCREEN STATUS BAR
;	LOGIC.  

;V1.96  SLIGHT IMPROVEMENT IN INITBACK FLICKER.  ALSO IN TTY.ASM.

;V1.97  ADDED VARIABLES RESULTX AND RESULTY FOR USERS TO READ FOLLOWING
;MOVESPRT.

;V1.98 FIXED A BAD RETURN ON USEDINDX WHICH COULD CAUSE SYSTEM CRASH.

;V1.99 MAKE MOVESPRT STOP AT TOP IF SPRITE IS POSITIONED ABOVE TOPBAR
;AND SOLID IS BEING CHECKED.  IT CHECKS FROM PIXEL ROW 0 RATHER THAN GOING
;INTO INVALID ROM AREAS.

;V2.00 ADDED VIDEOREQ BITS $80 AND $40 TO ALLOW CONTINUOUS SCROLLING
;BACKGROUNDS WHEN KILLBACK HAS BEEN USED TO TURN THEM OFF.  A USER WRITTEN
;ROUTINE COULD NOT SET XSCROLL AND YSCROLL SMOOTHLY BECAUSE THAT ROUTINE
;ALSO NEEDED TO BE ABLE TO AFFECT REG2000 BIT 01 (PAGE SELECT) AT THE
;NEXT NMI.

;V2.01 ADDED YADJ AND SPYADJ AND FLASH.

;V2.02 ADDED LOSTX AND LOSTY.

;V2.03 ADDED BASESPRITE AND TOOMANY.

;V2.04 ADDED LOADALL.

;V2.05 ADDED ROUTINE NEGATE.  MADE SPRITE SELECTION BY HORIZONTAL ALIGNMENT
;TAKE INTO ACCOUNT MIRRORING AND SELECT BACKWARDS IN THAT CASE

; ********************* SUBROUTINE RAM EQUATES *************************
;
;DO NOT REUSE THESE RAM AREAS WHEN DEFINING YOUR OWN EQUATES.  ALSO, DO
;NOT PUT ANY OF YOUR DEFFINITIONS HERE, USE THE AREA PRECEEDING THE
;BOOT CODE THAT HAS BEEN RESERVED FOR THIS PURPOSE.
;

	NMI_PTR= $00
 	BACKBASE= $02		;BACKGROUND DATA PTR
	BPAL_BASE= $04		;BACKGROUND PALETTE REG DATA BASE PTR
	SPAL_BASE= $06		;SPRITE PALETTE REG DATA BASE PTR

	SUBSVAR1= $08		;VARIABLE FOR USE BY THE SUBS.  OK TO
	SUBSVAR2= $09		;USE FROM BOTH NMI AND NON-NMI LEVEL
				;BECAUSE ITS SAVED AT NMI.  MUST STAY
				;IN LOW RAM FOR A POINTER.

	MAIN_PTR= $0A		;POINTER FOR USE BY MAINLINE ROUTINES

	TOOMANY= $0C		;SET TRUE BY NMI IF LAST SCREEN PAINT HAD
				;TOO MANY SPRITES ON THE LINE.

	SAVE_SPRITES = $100	;PLACE TO SAVE SPRITES LOCATION'S IF
				;WE ARE SCANNING FOR A GUN.  THIS IS THE		
				;LOW 64 BYTES OF THE STACK AREA AND THE
				;STACK IS SIMPLE RESTRICTED WHEN SCANNING
				;FOR A GUN HIT (ITS UNLIKELY TO PUSH THIS
				;MUCH).

	SPRAM = $200		;SPRITE RAM.  $200-$2FF
				;STORED IN FORMAT REQUIRED BY NES VIDEO
				;PROCESSOR EXCEPT FOR 1 BIT WE USE:
				;1 BYTE VERTICAL SCAN LINE FOR TOP SPRITE ROW
				;1 BYTE CHARACTER TO USE FROM CHAR SET
				;1 BYTE PALETTE AND FLIP SPEC:
				;	80H SET TO DISPLAY UPSIDE DOWN
				;	40H SET TO DISPLAY MIRROR IMAGE
				;	20H SET PUTS SPRITE BEHIND BACKGROUND
				;	08H USED BY US TO MARK IN USE
				;	XXB = PALETTE TO USE (0-3)
		 		;1 BYTE HORIZONTAL SCAN LINE FOR LEFT ROW

;THE FOLLOWING BUFFER IS USED TO HOLD ANY DATA TO BE WRITTEN TO THE
;SCREEN.  THE BUFFER HOLDS LIMITED DATA AND THE LIMIT IS DESIGNED TO
;BE THE MAX WE CAN SAFELY WRITE TO THE SCREEN WITHOUT OVERFLOWING
;THE VERTICAL RETRACE.  IF A ROUTINE WISHES TO WRITE TO SCREEN, IT 
;SHOULD BE ACTIVATED FROM THE TAIL END OF NMI WITH FLAGS THAT ARE SET.
;THE FIRST THING THE ROUTINE SHOULD DO WHEN CALLED IS CHECK ITS FLAG
;TO SEE IF IT NEEDS TO WRITE TO SCREEN.  IF IT DOES, IT SHOULD NEXT CHECK
;THIS BUFFER TO SEE IF IT CAN FIT ITS WRITE INTO THE REMAINING ROOM OF
;THE BUFFER.  SCSIZE HAS THE MAX THE BUFFER CAN HOLD AND SCCNT HAS THE
;AMOUNT ALREADY THERE.  IF THE BUFFER CAN'T HOLD THE SCREEN WRITE DATA
;THEN THE ROUTINE SHOULD LEAVE ITS FLAG SET AND FORGET IT THIS PASS
;OF NMI.  IF THE BUFFER CAN HOLD THE DATA, IT SHOULD INDEX TO THE NEXT
;UNUSED POSITION IN THE BUFFER, AND PUT THE FOLLOWING DATA INTO THE 
;BUFFER:
;
;HIGH BYTE OF SCREEN RAM LOCATION.  BIT 80H SET IF NEED VERTICAL WRITE.
;LOW BYTE OF SCREEN RAM LOCATION
;1 BYTE LENGTH OF DATA TO WRITE
;DATA FOR LENGTH SPECIFIED.
;
;THEN THE ROUTINE SHOULD ADD THE TOTAL LENGTH OF THE ABOVE DATA TO
;THE VARIABLE SCCNT.  AT NEXT NMI THE DATA WILL BE WRITTEN.  NO ROUTINE
;SHOULD HOG EACH NMI OR IT MAY LOCK OUT OTHER ROUTINES.

	SCBUF = $300		;SCREEN WRITE BUFFER.  LENGTH MAY CHANGE
	SCSIZE = $60		;AMOUNT THAT BUFFER CAN HOLD
	SCCNT = $381		;COUNT OF DATA IN BUFFER

	BPAL_BLINK = $382	;BACKGROUND PALETTE CONTROL RAM
	BPAL_DEPTH = $383
	BPAL_FREQ = $384
	BPAL_INDX = $385
	BPAL_CNT = $386

	NEW_PAL = $387		;BIT 01 SET IF NEW BACKGROUND PAL
				;BIT 02 SET IF NEW SPRITE PAL

	SPAL_BLINK = $388	;BACKGROUND PALETTE CONTROL RAM
	SPAL_DEPTH = $389
	SPAL_FREQ = $38A
	SPAL_INDX = $38B
	SPAL_CNT = $38C

	J1FLAGS = $38D		;JOYSTICK1 CURRENT STATE
	J2FLAGS = $38E		;JOYSTICK2 CURRENT STATE. ON=BUTTON DOWN.

 A_BUTTON = $80		;80H = A button		EQUATES TO MAKE IT
 B_BUTTON = $40		;40H = B button		EASIER TO TEST J1FLAGS
 SELECT = $20		;20H = Select
 START = $10			;10H = Start
 UP = 8			;08H = Up
 DOWN = 4			;04H = Down
 LEFT = 2			;02H = Left
 RIGHT = 1			;01H = Right

	J1CHANGE = $38F		;USED TO HOLD CHANGES IN JOYSTICK STATE
	J2CHANGE = $390

	REPCNT = $391		;AUTOREPEAT COUNT DOWN TIMER

	J1REPFLG = $392		;HOLDS BIT FOR EACH J1 BUTTON AUTOREPEATING
	J2REPFLG = $393		;HOLDS BIT FOR EACH J1 BUTTON AUTOREPEATING
	J1HOLD = $394		;USED TO DELAY START OF AUTOREPEAT BY 1 REPEAT
	J2HOLD = $395		;USED TO DELAY START OF AUTOREPEAT BY 1 REPEAT

	BEEPREG = $396		;A BEEP ROUTINE VARIABLE

	DOUBLE_BIT = $397	;THIS VARIABLE TRACKS THE VALUE OF REG2000'S
				;DOUBLE HIGH SPRITE BIT.

	CLEARPASS = $398		;TRUE IF WE ARE DOING A GUN CLEAR PASS.  
				;WE PAINT THE SCREEN BLACK.

	VERIFYPASS = $399	;TRUE IF WE ARE DOING A VERIFY PASS FOR THE
				;GUN.

	VERIFYFAILS = $39A	;NUMBER OF TIMES THE GUN VERIFY FAILED.
				;INDICATES TV NEEDS ADJUSTING.

	CURGUN = $39B		;0 OR 1 CURRENT LIGHT GUN THAT WE ARE CHECKING
				;FOR A HIT.  -1=NONE

	GUNWAIT = $39C		;DELAY TO SLOW FIRING GUN.
;		 $39D		;2 COPIES THAT ARE INDEXED TO SUPPORT 2 GUNS.

	TARGETNUM = $39E		;CURRENT TARGET BEING CHECKED BY GUNS
;		$39F		;2 COPIES THAT ARE INDEXED TO SUPPORT 2 GUNS.

	GUNREG = $3A0		;USED TO TAKE SAMPLES OF THE GUN'S LIGHT BIT 
;		$3A1		;DURING VIDEO SCANNING.  THE FINAL SAMPLE
				;IS MOVED INTO LIGHTBIT AT START OF NMI.
				;THERE ARE 2 COPIES OF EACH VARIABLE BECAUSE
				;THERE ARE 2 GUNS.

	LIGHTBIT = $3A2		;FALSE IF THE GUN SAW LIGHT LAST NMI CYCLE.
;		$3A3		;TRUE IF THE GUN DID NOT SEE LIGHT.  FIRST
				;COPY IS FOR GUN1,  SECOND FOR GUN2.

	BACKVALID = $3A4		;TRUE IF THE BACKGROUND IS VALID. MAKE_SCROLL
				;WILL NOT CHANGE SCROLL VALUES IF FALSE.

	ROW = $3A5		;USED WITH TTY TO HOLD THE CURSOR "ROW"
	COL = $3A6		;USED WITH TTY TO HOLD THE CURSOR "COLUMN"
	TOPROW = $3A7		;CURRENT ROW 0 FOR DISPLAY PURPOSES

	SOLIDCHAR = $3A8		;THE SOLID CHAR WE HIT WITH MOVESPRT

	PAGETEMP = $3A9		;FOR USE WITH THE PAGING LOGIC IN MEMORY.ASM

	SPRITES_HIDDEN = $3AA	;SET DURING GUN SCANNING IF THE SPRITE'S Y
				;LOCATIONS ARE ACTUALLY STORED IN LOW STACK
				;RAM AT SAVE_SPRITES.  THIS HAPPENS BECAUSE
				;WE NEED TO HIDE SPRITES TO PUT UP THE GUN
				;SPRITE BLOCK.

	TTYBASE = $3AB		;SET TO $20 AT BOOT TO SPECIFY PAGE USED
				;BY THE TTY ROUTINE.

	GUNRELOAD = $3AC		;GUNDELAY RELOAD VALUE TO MAKE IT USER
				;MODIFIABLE.

	VIDEOREQ = $3AD		;VIDEO CHANGE REQUEST.  USED BY NMI ROUTINE,
				;ANYONE MAY SET BITS TO REQUEST FUNCTIONS:
				;01 = DISABLE BACKGROUND VIDEO IN REG2001.
				;02 = ENABLE BACKGROUND VIDEO IN REG2001
				;40 = RESET BIT 01 IN REG2000
				;80 = SET BIT 01 IN REG2000 

				;THE FOLLOWING BITS ARE VALID ONLY IF GUN
				;LOGIC IS ACTIVE.  
				;
				;04 = SET BACKGROUND COLOR TO GUN BLACK AND
				;     SPRITE COLOR 3 OF PALETTE 0 TO WHITE.
				;08 = RESTORE BACKGROUND COLOR AND SPRITE
				;     COLOR 3, PALETTE 0.

	LASTTARGET = $3AE 	;TRUE IF WE HAVE NO MORE GUN TARGETS TO CHECK.

	WORKINGPAGE = $3AF	;USED BY SELPAGE, COULD POSSIBLY BE FREED

	BLACKCLR = $3B0		;COLOR TO USE FOR GUN BLACK.

	RESULTX = $3B1
	RESULTY = $3B2		;RETURNS X AND Y FOLLOWING MOVESPRT OR PUTSPRT

	YADJ = $3B3		;Y SCROLL ADJUSTMENT.  USER SETTABLE.
	SPYADJ = $3B4		;SPRITE'S Y ADJUSTMENT.  USER SETTABLE.

	LOSTX = $3B5
	LOSTY = $3B6		;USED BY MOVESPRT

	BASESPRITE = $3B7	;BASE SPRITE TO LOAD AT.  ALTERNATE BETWEEN
				;0 AND $80 TO FLICKER THE SPRITES.  ITS
				;LOADED WITH 0 AT BOOT.
;3B8 - 3CA UNUSED

	OURINDX = $3CB		
	COLL1 = $3CC
	COLL2 = $3CD
	COLL3 = $3CE
	COLL4 = $3CF		;FOR USE WITH ROUTINE "COLLISION"

	COLLINDX = $3D0		;FOR USE WITH ROUTINE "NEXT_COLL".

	REG4015 = $3D1		;VOICE ENABLE REG CURRENT STATE

	BPBASE = $3D2		;BACKGROUND PALETTE INFO PTR

	XOBJ = $3D4
	YOBJ = $3D5		;FOR PUTOBJ CALL

	SUBSVAR3 = $3D6		;NON-PTR CAPABLE SUBS FOR USE FROM ANY LEVEL.
	SUBSVAR4 = $3D7		
	SUBSVAR5 = $3D8

	SCRLDIF = $3D9		;FOR USE BY SCROLL ROUTINE.

	ROMPAGE = $3DA		;BITS 03H = PROGRAM ROM PAGE. 
				;BITS F0H = VIDEO ROM PAGE.
				;BITS 0CH SHOULD BE LEFT OFF AT ALL TIMES.
				

	MATH1 = $3DB		;TEMPORARY VARIABLES FOR USE BY MATH ROUTINES.
	MATH2 = $3DC		;SAVED EACH NMI AND RESTORED TO ALLOW ALL
	MATH3 = $3DD		;TO USE MATH ROUTINES.  THESE MAY BE USED
	MATH4 = $3DE		;AS TEMP VARIABLES ALSO BUT WILL BE CHANGED
				;IF A MATH ROUTINE IS CALLED.

	MOVEBACK = $3DF		;SET TRUE IF BACKGROUND NEEDS MOVING.  
				;BIT ORIENTED:
				;01 = X MIGHT NEED SCROLLING
				;02 = Y MIGHT NEED SCROLLING

	BPWIDE = $3E0		;WIDTH OF PALETTE INFO ASSOCIATED WITH BACKGRND

	XBACK = $3E1		;USER SET DESIRED X PIXEL LOCATION IN BACKGND
	YBACK = $3E3		;USER SET DESIRED Y

	END_ROW = $3E5		;USED TO ADJUST SCROLL POSITIONS
	END_COL = $3E6		;IN BACKGROUND MODE.

	CURX = $3E7		;CURRENTLY DRAWN X PIXEL BACKGROUND LOCATION
	CURY = $3E9		;CURRENTLY DRAWN Y PIXEL LOCATION
	BACKSIZE = $3EB		;1 OR 2 SIZE OF BACKGROUND BLOCKS
	BACKWIDE = $3EC		;WIDTH IN BLOCKS OF BACKGROUND
	BACKHIGH = $3ED		;HEIGHT IN BLOCKS OF BACKGROUND

	TMP_NMI1 = $3EE		;TEMPORARY VARIABLES TO USE DURING NMI INT.
	TMP_NMI2 = $3EF		;RULES FOR USE:  EVEN USER SUBS MAY USE
	TMP_NMI3 = $3F0		;THESE VARIABLES BUT NO ROUTINE SHOULD 
	TMP_NMI4 = $3F1		;EXPECT ANY VALUES TO STAY HERE WHEN ANOTHER
	TMP_NMI5 = $3F2		;SUB IS CALLED UNLESS THAT ROUTINE 
	TMP_NMI6 = $3F3		;SPECIFICALLY STATES THAT THE VARIABLES ARE
	TMP_NMI7 = $3F4		;NOT USED.
	TMP_NMI8 = $3F5
	TMP_NMI9 = $3F6
	TMP_NMIA = $3F7
	TMP_NMIB = $3F8
	TMP_NMIC = $3F9
	TMP_NMID = $3FA
	TMP_NMIE = $3FB

	XSCROLL = $3FC		;X SCREEN SCROLL VALUE
	YSCROLL = $3FD		;Y SCREEN SCROLL VALUE
	REG2001 = $3FE		;VALUE TO WRITE TO $2001 TO ENABLE VIDEO
	REG2000 = $3FF		;THE VALUE WE WRITE TO $2000 MINUS NMI ENABLE

;******        SPRITE BLOCK AND ANIMATION RAM.        ******
;
;THE SPRITE BLOCKS AND ANIMATION SPECIFICATIONS ARE STORED HERE.  THE
;MAXIMUM NUMBER OF ACTIVE BLOCKS IS DETERMINED BY THE VARIABLE SPSLOTS.
;EACH BLOCK OR ANIMATION USES 7 BYTES OF RAM.  YOU MAY CHANGE SPSLOTS
;BUT WATCH YOUR RAM USAGE.  THIS VARIABLE IS IN USERASM.ASM

	ANIM_WIDE = 11		;WIDTH OF EACH ENTRY.  NOT USER CHANGABLE.
	SPMEM = SPSLOTS*ANIM_WIDE	;AMOUNT OF RAM USED BY THE SPRITE SLOTS
	ANIM_RAM = $400		;BASE SLOT OF ANIMATION/SPRITE RAM
				;FORMAT:
	FB = 0			;FLAG BYTE: 	0=SLOT AVAILABLE,
				;		80H SET IF STRUCTURE NOT 
				;		    POSITIONED YET.
				;		40H SET IF ANIMATION IS
				;		    FROZEN.
				;		20H SET IF ANIMATION UPDATE
				;		    BY X ALIGNMENT.
				;		10H SET IF ANIMATION UPDATE
				;		    BY Y ALIGNMENT.
				;		08H SET IF SOLID CHAR DEFINED.
				;		
				;		BITS 07 ARE STRUCTURE TYPE:
				;		  1=SPRITE, 2=SPRITE ANIM.,
				;		  3=OBJECT ANIMATION.
				;
	AF = 1			;AUXILARY FLAGS:
				;		BITS 07H = SHIFT COUNT
				;		  FOR ALIGNMENT BY X OR Y.
				;		BIT 20H = AUTOKILL IF SET.
				;		BIT 40H = MIRROR IMAGE.
				;		  WHEN SET SPRITE IS FLIPPED
				;		  FROM LEFT TO RIGHT.
				;		BIT 80H = UPSIDE DOWN
				;		  WHEN SET SPRITE IS DISPLAYED
				;		  UPSIDE DOWN FROM ORIGINAL
				;		  SPECIFICATION.			

	PTRL = 2			;WORD PTR TO DATA OR ANIMATION LIST
	PTRH = 3
	BS = 4			;IF SPRITE, BASE SPRITE*4 INDEX (BYTE).
				;IF OBJECT ANIMATION THEN LOW 4 BITS ARE
				;COLUMN POSITION/4, HIGH ARE ROW POSITION/4
	NS = 5			;IF SPRITE, NUMBER OF SPRITES (BYTE).
				;IF OBJECT, BIT 80H SET IF REFRESH NEEDED.
				;           BITS 7FH ARE AMOUNT OF RAM NEEDED
				;	    TO WRITE AN UPDATE OUT.
	FR = 6			;CURRENT ANIMATION FRAME (BYTE)
	CN = 7			;COUNT DOWN TO NEXT FRAME CHANGE (BYTE)
	RL = 8			;RELOAD VALUE FOR COUNT DOWN (BYTE). INITIALLY
				;   LOADED WITH VALUE FROM ANIMATION, THEN
				;   ITS USER CHANGEABLE.
	SL = 9			;SOLID CHAR VALUE.  ONLY VALID IF SOLID
				;   DEFINED BIT SET IN FLAGS.
	ABL = 10			;BLINK COUNTER.  IF TRUE, HERO IS BLINKING.
				;HE WILL BLINK FOR THIS MUCH IN 1/60 TICKS.

;HERE ARE THE SOUND SLOTS.  THEY FOLLOW THE SPRITE SLOTS IN MEMORY AND
;USE THE EQUATES ABOVE TO DETERMINE THEIR BASE LOCATION.  ALL SLOT ORIENTED
;STRUCTURES SHOULD FOLLOW THIS STRATEGY OF CALCULATING THEIR LOCATION
;BASED ON THE PREVIOUS NUMBER OF SLOTS.  YOU CAN CHANGE THE NUMBER
;OF SOUND STRUCTURES BY SETTING SNDSLOTS IN USERASM.ASM

	SND_WIDE = 7		;WIDTH OF EACH ENTRY.  NOT USER CHANGABLE.
	SNDMEM = SNDSLOTS*SND_WIDE ;AMOUNT OF RAM USED BY THE SPRITE SLOTS
	SND_RAM = $400+SPMEM	;BASE SLOT OF ANIMATION/SPRITE RAM
				;FORMAT:
	SF = 0			;SOUND FLAG:  BIT 80H SET IF SLOT IN USE.
				;	      BIT 40H SET IF SOUND HAS NOT
				;             BEEN ASSIGNED TO A REGISTER SET.
				;	      BIT 20H SET IF SOUND SUSPENDED
				;	        BY ANOTHER VOICE.
				;             LOW BITS SPECIFY LOW BYTE OF
				;	      REGISTER SET BASE (0,4,8,ETC).
	ST = 1			;SOUND TIMER.  LOADED WITH NOTE OR PAUSE
				;             DURATION IN 1/60 SECOND TICKS.
	SBL = 2			;BASE POINTER (WORD) TO THE ORIGINAL SOUND
	SBH = 3			;	      STRUCTURE PASSED IN CALL.
	SOL = 4			;SOUND OFFSET OF CURRENT PLAY LOCATION.			
	SOH = 5
	SI = 6			;INSTRUMENT CURRENTLY ACTIVE.  USED TO 
				;	      RESTORE SOUND IF SUSPENDED.

;************************** BOOT VECTOR ************************
;
;THIS BOOT VECTOR IS FOR THE SUBROUTINES.  DON'T PUT YOUR CODE HERE,
;PUT IT IN THE LEGAL BOOT SUBROUTINE "USER_BOOT" AT THE END OF THIS ASSEMBLY.

;THIS ROUTINE SIMPLE DISABLES VIDEO AND NMI, WAITS FOR THE VIDEO PROCESSOR
;TO RESET, AND THEN INITIALIZES OUR VARIABLES.  CODE WILL EVENTUALLY
;BE ADDED TO WORK IN CONJUNCTION WITH SPECIAL FEATURES OF THE COLOR
;DREAMS INC. CARTRIDGES BUT THIS IS NOT YET RELEASED INFO.

BOOT:	SEI			;DISALLOW IRQ INTERRUPTS

	LDA	#0
	STA	$2000		;MAKE SURE NMI INTS ARE OFF

;WAIT FOR VIDEO SYNC PULSES. WE NORMALLY JUST NEED TO DO THIS AT BOOT
;TO WAIT FOR THE VIDEO TO GET OUT OF RESET.  AFTER THIS KEY CHIP LOGIC
;THIS IS PROBABLY UNNECESSARY.

	JSR	VERT_WAIT	
	JSR	VERT_WAIT	;WAIT FOR 2 TO MAKE SURE BIT IS VALID

	LDA	#6
	STA	$2001

;INCLUDE( PULSES.ASM)		;DO THE KEY CHIP LOGIC.
.include "PULSES.ASM"
;INITIALIZE THE VARIABLES WE USE.

	LDA	#0		;This is located at $0058 of the rom
	STA	NEW_PAL		;RESET FLAG OF PALETTE NEEDS INIT
	STA	ROMPAGE		;CLEAR THE VIDEO AND PROGRAM ROM PAGES
	STA	SCCNT		;ZERO DATA TO WRITE TO SCREEN
	STA	XSCROLL
	STA	YSCROLL		;ZERO SCROLL
	STA	CURX
	STA	CURY		;ZERO BACKGROUND SCROLL LOW VALUES FOR PUTSPRT
	STA	BACKVALID
	STA	MOVEBACK	;RESET FLAG TO SCROLL BACKGROUND
	STA	BPAL_BLINK
	STA	SPAL_BLINK	;PREVENT PALETTE UPDATES
	STA	J1FLAGS
	STA	J2FLAGS
	STA	J1HOLD
	STA	J2HOLD
	STA	J1REPFLG
	STA	J2REPFLG	;RESET BUTTON LOGIC
	STA	REG2000		;AND ZERO SCREEN PAGE 
	STA	DOUBLE_BIT
	STA	REG4015		;AND SOUND ENABLE REG
	STA	SPRITES_HIDDEN
	STA	VERIFYFAILS	;RESET GUN TARGET FAILURES
	STA	VIDEOREQ
    	STA	YADJ
	STA	SPYADJ
	STA	BASESPRITE

	LDA	#GUNDELAY	;$00A8
	STA	GUNWAIT		;RESET GUN DELAYS
	STA	GUNWAIT+1	
	STA	GUNRELOAD	;SET RELOAD VALUE

	LDA	#-1
	STA	CURGUN

	LDA	#REPRATE
	STA	REPCNT		;RELOAD THE JOYSTICK REPEAT RATE

	LDA	#$20
	STA	TTYBASE		;$00BF
;Evenball: I'm confused... Is all the stuff below for GUNLOGIC or what?
;IFDEF( `GUNLOGIC', `
.ifdef GUNLOGIC
	LDA	#14
	STA	BLACKCLR	;SET BLACK FOR THE GUN', )

	LDA	#$1E
	STA	REG2001		;SET UP FOR SPRITES, BACKGROUND, NO ODD COLORS
				;AND 32 COL MODE FOR ALL.

	JSR	HIDESPRITES	;FREE UP AND HIDE THE SPRITES
	JSR	CLEARTOP	;AND CLEAR THAT SCREEN AREA
	JSR	ZERO_ANIM	;CLEAR THE ANIMATION RAM
	JSR	TOPSPRITE		;IF TOP SCREEN STATUS, MOVE SPRITE #0

;IFDEF( `GUNLOGIC', JSR GUNSPRITE, )	;IF GUN ENABLED, TAKE OVER SPRITES

	JSR 	GUNSPRITE	;I  added this because I think the ifdef is redundant
				;-Evenball
	JSR	ZERO_SOUND

;CALL THE USER'S BOOT CODE.

	JSR	USER_BOOT

;ALLOW NMI INTERRUPTS.

	LDA	REG2000
	ORA	#$80		;ENABLE NMI INTS
	STA	$2000

;NON-INTERRUPT MAINLINE.  WE TAKE LIGHT GUN SAMPLES AND
;CALL THE USER NON-NMI PROGRAM.

B1000:	JSR	USER_MAINLINE

;IFDEF( `GUNLOGIC', JSR AND_GUN, ) 	;TAKE A LIGHT GUN SAMPLE
	JSR 	AND_GUN		;I  added this because I think the ifdef is redundant
				;-Evenball
	JMP	B1000
.endif
;********************** USER SELECTABLE CODE AREA *******************
;
;THIS AREA JUST "INCLUDES" THE MODULES CALLED AS CHANGABLE
;SUBS AT VARIOUS POINTS IN THE PROGRAM.  FOR INSTANCE, TO PUT A TOP
;SCORE STATUS BAR AT SCREEN TOP REQUIRES DIFFERENT LOGIC THAN TO NOT
;PUT ONE.  THERE ARE 2 FILES DEFINED AND ONE FILE IS LOADED DEPENDING
;ON THE SITUATION.  THE USER DEFINES A VARIABLE "TOPBAR" IN HIS
;USERASM FILE AND IF THIS IS DEFINED THEN THE TOP OF SCREEN STATUS FILE
;IS LOADED.  OTHERWISE THE NORMAL FILE IS LOADED.  BOTH FILES CONTAIN
;THE EXACT SAME SUBS BY NAME AND THESE ARE CALLED AT VARIOUS POINTS IN
;THE PROGRAM.  THEY WILL BEHAVE DIFFERENTLY DEPENDING ON WHAT WAS LOADED.

;THESE VARIABLE FILE LOADS CONTROL THE TOP AND BOTTOM OF SCREEN STATUS 
;BARS.

;IFDEF( `TOPBAR', `INCLUDE( TOPSTAT.ASM)', )
.ifdef TOPBAR
.include "TOPSTAT.ASM"
.endif
;IFDEF( `TOPBAR', , `INCLUDE( NORMTOP.ASM)')
;	Evenball: I'm assuming the double , means ifndef
;Added by Evenball. I'm not sure where this code came from
;This code starts at $00C2 in the retail rom
.byte	$A9, $1E, $8D, $FE, $03, $20
.byte 	$29, $9E, $20, $F2, $80, $20, $6D, $8C
.byte 	$20, $F2, $80, $20, $C5, $84, $20, $8B
.byte 	$CE, $AD, $FF, $03, $09, $80, $8D, $00
.byte 	$20, $20, $C1, $CE, $4C, $D1, $80
.ifndef TOPBAR
.include "NORMTOP.ASM"
.endif

;THIS FILE IS LOADED IF THE PROGRAMMER WANTS LIGHT GUN SUPPORT

;IFDEF( `GUNLOGIC', `INCLUDE( GUN.ASM)', )
.ifdef GUNLOGIC
.include "GUN.ASM"
.endif

;THIS FILE IS LOADED IF THE USER WANTS TTY OUTPUT ROUTINES

;IFDEF( `TTYFLG', `INCLUDE( TTY.ASM)', )
.ifdef TTYFLG
.include "TTY.ASM"
.endif

;************************ NMI INTERRUPT ***************************
;
;THIS IS THE NMI SERVICE ROUTINE.  IT COMPLETELY CONTROLS ALL WRITES
;TO THE SCREEN AND YOUR CODE SHOULD NOT VIOLATE THIS SCHEME OR YOU
;MAY LOOSE COMPATIBILITY WITH THESE SUBS.  IF YOU WANT TO DO PROCESSING
;UNDER NMI (AND IT IS STRONGLY RECOMMENDED THAT ALL OF YOUR PROCESSING
;IS DONE IN THIS MANNER) PUT YOUR CODE INTO THE ROUTINE "USER_NMI"
;AT THE END OF THIS ASSEMBLY.  IF YOU WANT TO WRITE TO RAM, FOLLOW
;THE RULES FOR PUTTING DATA INTO SCBUF.  SEE THE COMMENTS ON SCBUF
;IN THE RAM EQUATES.


;THIS NMI ROUTINE USES THE FOLLOWING STRATIGY:
;
;1. ALL DATA TO WRITE TO SCREEN IS KEPT IN A BUFFER WHICH CANNOT
;HOLD MORE THAN CAN BE SUCCESSFULLY WRITTEN.  AT NMI START, THE
;SPRITES DMA TRANSFER IS STARTED AND THEN WHATEVER IS QUED IN THE
;BUFFER IS WRITTEN.  THEN VIDEO IS RE-ENABLED (BUT NOT NMI INTS).
;
;2. ROUTINES THAT SET FLAGS TO GET PROCESSOR POWER OFF THE NMI TICK
;ARE CALLED IF THEIR FLAGS ARE SET.  THEY ONLY CALCULATE AND PUT DATA
;INTO THE SCREEN BUFFER, THEY NEVER ACCESS VIDEO DIRECTLY.  IF THEY 
;CANNOT FIT THEIR DATA IN THE BUFFER THEY IGNORE THIS NMI.
;
;3. THE JOYSTICK IS CHECKED AND THE USER JOYSTICK ROUTINES ARE CALLED
;FOR ALL CHANGES.
;
;4. THE USER PROGRAM NMI PROCESSOR ROUTINE IS CALLED.  THIS ROUTINE
;MUST ALSO USE ONLY THE BUFFER OR THE SUBROUTINES AND MUST NOT WRITE
;TO VIDEO.


;TRANSFER THE DMA AND WRITE OUT THE SCREEN BUFFER.
;located at $8236 logically, $0246 in rom	
NMI:	PHA

	TXA	
	PHA
	TYA
	PHA	;SAVE THE REGISTERS

	LDA	REG2000
	AND	#$7F		;DISABLE NMI
	STA	$2000

	LDA	$2002		;RESET ADDRESS REG SELECT FOR THROUGHOUT NMI.
	AND	#$20
	STA	TOOMANY
	LDA	#06
	STA	$2001		;DISABLE VIDEO TO ALLOW SCREEN ACCESS

	LDA	BASESPRITE
	STA	$2003		;ZERO THE SPRITE INDEX REG OR LOAD WITH THE $0262
				;USER SELECTED VALUE.
	
	LDA	$2004		;$0265
	LDA	$2004

OOOP:	LDA	#SPRAM	>> 8	;GET PAGE OF SPRITE RAM
	STA	$4014		;START THE SPRITE RAM DMA TRANSFER

	JSR	WRITE_SCBUF	;WRITE OUT ANY DATA IN SCBUF $0270
	JSR	MAKE_SCROLL	;SCREEN UPDATED, MAKE ANY NEW SCROLL NEEDED


;IFDEF( `GUNLOGIC', JSR GET_SAMPLE, ) 	;TAKE THE LAST SAMPLE AND PUT FOR
					;GUN SUBS.  RESET THE LIGHT SAMPLE.
.ifdef GUNLOGIC
	JSR 	GET_SAMPLE
.endif

;SEE IF ANY CHANGES TO THE VIDEO STATE HAVE BEEN REQUESTED.

	LDA	VIDEOREQ	;$0276
	BEQ	N100
	AND	#1		;DISABLE BACKGROUND VIDEO?
	BEQ	N20
	EOR	VIDEOREQ
	STA	VIDEOREQ	;RESET THAT BIT
	LDA	REG2001
	AND	#$F7		;DISABLE BACKGROUND VIDEO
	STA	REG2001

N20:	LDA	VIDEOREQ	;SEE IF ENABLE VIDEO $028C
	AND	#2
	BEQ	N25
	EOR	VIDEOREQ
	STA	VIDEOREQ
	LDA	REG2001
	ORA	#8
	STA	REG2001

N25:	LDA	VIDEOREQ	;$02A2
	AND	#4		;BLACKEN PALETTE AND WHITEN SPRITES?
	BEQ	N27
	EOR	VIDEOREQ
	STA	VIDEOREQ

;IFDEF( `GUNLOGIC', JSR BLACKEN_PAL, ) 	
.ifdef GUNLOGIC
	JSR 	BLACKEN_PAL
.endif

N27:	LDA	VIDEOREQ	;$02AF
	AND	#8		;RESTORE PALETTE COLOR AND SPRITES?
	BEQ	N28
	EOR	VIDEOREQ
	STA	VIDEOREQ

N28:	LDA	VIDEOREQ	;$02BC
	AND	#$C0		;SEE IF NEED STATE CHANGE TO REG2000
	BEQ	N30
	TAX
	EOR	VIDEOREQ
	STA	VIDEOREQ
	TXA
	BPL	N29
    	LDA	REG2000
	ORA	#1
	STA	REG2000
	JMP	N30

N29:	LDA	REG2000
	AND	#$FE
	STA	REG2000

;IFDEF( `GUNLOGIC', JSR FIXPAL, ) 
.ifdef GUNLOGIC
	JSR 	FIXPAL
.endif

N30:	LDA	#0
	STA	VIDEOREQ	;REMAINING BITS INVALID

;DONE WRITING OUT THE SPRITE AND SCREEN DATA.  USE THE CORRECT LOGIC
;TO ENABLE VIDEO AND SCROLL AS NEEDED.  THE 2 POSSIBILITIES ARE
;TOP OF SCREEN STATUS BAR OR NONE.  WE JUST CALL A ROUTINE THAT IS
;SELECTIVELY LOADED DURING ASSEMBLY.

N100: 	JSR	FINISH_TOP

;VIDEO IS ENABLED.  CALL ROUTINES THAT DO PROCESSING WHEN ACTIVATED
;BY FLAGS.  WE HAVE TO PRIORITIZE THEM.

;WE FIRST SAVE OFF A FEW MEMORY VARIABLES THAT ARE DEFINED TO BE USABLE
;BY ALL.

	LDA	SUBSVAR1
	PHA
	LDA	SUBSVAR2
	PHA
	LDA	SUBSVAR3
	PHA
	LDA	SUBSVAR4
	PHA
	LDA	SUBSVAR5
	PHA			;SAVE SUB VARIABLES SO THAT THE SUBS MAY
				;BE USED FROM ANY LEVEL.
	LDA	MATH1
	PHA
	LDA	MATH2
	PHA			
	LDA	MATH3
	PHA			
	LDA	MATH4
	PHA			;SAVE MATH SUBS VARIABLES

;IFDEF( `GUNLOGIC', JSR AND_GUN, ) 	;TAKE A LIGHT GUN SAMPLE
.ifdef GUNLOGIC
	JSR 	AND_GUN
.endif

	JSR	DOPAL		;UPDATE PALETTES IF NEEDED
	JSR	DOSCRL		;SCROLL THE BACKGROUND IF NEEDED
	JSR	CHECK_ANIM	;SEE IF ANIMATIONS NEED PROCESSING
	JSR	FEED_SOUND	;FEED THE SOUND CHIP

;CHECK FOR JOYSTICK CHANGES.

N213:	LDA	#1
	STA	$4016
	LDA	#0
	STA	$4016		;LATCH A VALUE TO SHIFT.  ALSO LATCHES 4017.

	LDA	#0
	STA	J1CHANGE	;ZERO RESULT
	LDX	#8
N200:	LDA	$4016
	ROR	A
	ROL	J1CHANGE	;MOVE BIT UP INTO OUR BYTE
	DEX
	BNE	N200
	LDA	J1CHANGE	;GET NEW VALUE
	TAX			;SAVE NEW VALUE
	EOR	J1FLAGS		;GET CHANGES
	STA	J1CHANGE	;SAVE CHANGES
	STX	J1FLAGS		;AND CURRENT STATE

	LDA	#0
	STA	J2CHANGE	;ZERO RESULT
	LDX	#8
N210:	LDA	$4017
	ROR	A
	ROL	J2CHANGE	;MOVE BIT UP INTO OUR BYTE
	DEX
	BNE	N210
	LDA	J2CHANGE	;GET NEW VALUE
	TAX			;SAVE NEW VALUE
	EOR	J2FLAGS		;GET CHANGES
	STA	J2CHANGE	;SAVE CHANGES
	STX	J2FLAGS		;AND CURRENT STATE

;DO THE NECESSARY AUTOREPEAT LOGIC. 
;FIRST WE RESET ANY AUTOREPEATING KEYS THAT ARE NO LONGER DOWN.

	LDA	J1FLAGS
	AND	J1REPFLG	
	STA	J1REPFLG
	LDA	J1FLAGS
	AND	J1HOLD
	STA	J1HOLD		;RESET ANY NO LONGER DOWN IN JOYSTICK 1 FLAGS

	LDA	J2FLAGS
	AND	J2REPFLG
	STA	J2REPFLG
	LDA	J2FLAGS
	AND	J2HOLD
	STA	J2HOLD		;RESET ANY NO LONGER DOWN IN JOYSTICK 2 FLAGS

;SEE IF THE REPEAT COUNTER HAS RUN DOWN.  

	DEC	REPCNT		;COUNT DOWN THE REPEAT COUNTER
	BNE	N215		;SKIP IF NOT TIME TO REPEAT AGAIN.
	LDA	#REPRATE
	STA	REPCNT		;RELOAD IT

	LDA	J1REPFLG	;GET THE REPEATING KEYS
	ORA	J1CHANGE
	STA	J1CHANGE	;SET AS IF ITS A CHANGED KEY

	LDA	J2REPFLG	
	ORA	J2CHANGE
	STA	J2CHANGE

	LDA	J1HOLD		;GET KEYS WAITING TO AUTOREPEAT NEXT PASS
	AND	#J1REPENA	;BUT ONLY WANT THOSE ENABLED TO REPEAT
	STA	J1REPFLG	;SET TO REPEAT NEXT COUNT
	LDA	J1FLAGS
	STA	J1HOLD		;MOVE CURRENT STATE INTO THE HOLDING FLAG

	LDA	J2HOLD		;GET KEYS WAITING TO AUTOREPEAT NEXT PASS
	AND	#J2REPENA	;BUT ONLY WANT THOSE ENABLED TO REPEAT
	STA	J2REPFLG	;SET TO REPEAT NEXT COUNT
	LDA	J2FLAGS
	STA	J2HOLD		;MOVE CURRENT STATE INTO THE HOLDING FLAG

;CALL THE USER JOYSTICK ROUTINES TO SERVICE ANY CHANGED BUTTON.
;IF YOU WANT TO GET ONLY BUTTONS THAT GO DOWN, REMOVE THE COMMENT FROM
;THE AND INSTRUCTION IMMEDIATLY PRECEEDING THE BIT TESTS.

N215:	LDA	J1CHANGE	;GET JOYSTICK 1 CHANGES

	AND	J1FLAGS		;THIS LINE SELECTS ONLY KEYS GOING DOWN.
				;COMMENT THIS ROUTINE TO REPORT ALL CHANGES.

	BEQ	N240		;SKIP IF NO JOYSTICK CHANGES THIS PASS.

	ROR	J1CHANGE
	BCC	N220
	JSR	RIGHT1
N220:	ROR	J1CHANGE
	BCC	N221
	JSR	LEFT1
N221:	ROR	J1CHANGE
	BCC	N222
	JSR	DOWN1
N222:	ROR	J1CHANGE
	BCC	N223
	JSR	UP1
N223:	ROR	J1CHANGE
	BCC	N224
	JSR	STRT1
N224:	ROR	J1CHANGE
	BCC	N225
	JSR	SEL1
N225:	ROR	J1CHANGE
	BCC	N226
	JSR	B1
N226:	ROR	J1CHANGE
	BCC	N240
	JSR	A1

N240:	LDA	J2CHANGE	;GET JOYSTICK 2 CHANGES

	AND	J2FLAGS		;THIS LINE SELECTS ONLY KEYS GOING DOWN.
				;COMMENT THIS ROUTINE TO REPORT ALL CHANGES.

	BEQ	N260

	ROR	J2CHANGE
	BCC	N250
	JSR	RIGHT2
N250:	ROR	J2CHANGE
	BCC	N251
	JSR	LEFT2
N251:	ROR	J2CHANGE
	BCC	N252
	JSR	DOWN2
N252:	ROR	J2CHANGE
	BCC	N253
	JSR	UP2
N253:	ROR	J2CHANGE
	BCC	N254
	JSR	STRT2
N254:	ROR	J2CHANGE
	BCC	N255
	JSR	SEL2
N255:	ROR	J2CHANGE
	BCC	N256
	JSR	B2
N256:	ROR	J2CHANGE
	BCC	N260
	JSR	A2

;CALL THE USER SUBROUTINE.

N260:

;IFDEF( `GUNLOGIC', JSR AND_GUN, ) 	;TAKE A LIGHT GUN SAMPLE
.ifdef GUNLOGIC
	JSR 	AND_GUN
.endif

	JSR	USER_NMI

;CHECK FOR ACTIVE GUN SCANNING OR A NEW TRIGGER PRESS

;IFDEF( `GUNLOGIC', JSR CHECK_GUN, )
.ifdef GUNLOGIC
	JSR 	CHECK_GUN
.endif

;DONE WITH THIS NMI.  REENABLE NMI INTERRUPTS AND RESTORE REGS.

N380:	PLA
 	STA	MATH4
 	PLA
 	STA	MATH3
 	PLA
 	STA	MATH2
 	PLA	
 	STA	MATH1

 	PLA
 	STA	SUBSVAR5
 	PLA
 	STA	SUBSVAR4
 	PLA
 	STA	SUBSVAR3
 	PLA
 	STA	SUBSVAR2
 	PLA
 	STA	SUBSVAR1	

 	PLA
 	TAY
 	PLA
	TAX

	LDA	REG2000
	ORA	#$80
	STA	$2000

	PLA
	RTI

;********************* SUBROUTINE AREA ***************************
;
;THIS AREA CONTAINS BOTH ROUTINES YOU MAY CALL AS DOCUMENTED IN 
;THE SUBS.DOC AND ALSO SUPPORT ROUTINES USED BY THE SUBS THEMSELVES.
;DON'T PUT ANY OF YOUR CODE HERE OR YOU WILL BECOME INCOMPATIBLE WITH
;NEW RELEASES.

;THIS ROUTINE WILL PRODUCE A DIFFERENT BEEP FOR EACH VALUE IN A.  IT SAVES
;ALL REGISTERS.

BEEPA:
	STA	BEEPREG
	PHA
	TXA
	PHA
	TYA
	PHA

	LDA	#1
	STA	$4015
	LDA	BEEPREG
	LDY	#0
	ASL	A
	TAX
	TYA
	ROL	A
	TAY
	TXA
	ASL	A
	TAX
	TYA
	ROL	A
	STX	$4002
	STA	$4003	
	PLA
	TAY
	PLA
	TAX
	PLA
	RTS

;THE FOLLOWING EQUATES ARE USED TO MAKE MUSIC STRINGS.

	LC 	= $00
	LCs 	= $01
	LDb 	= $01
	LD 	= $02
	LDs 	= $03
	LEb 	= $03
	LE 	= $04
	LF 	= $05
	LFs	= $06
	LGb 	= $06
	LG 	= $07
	LGs 	= $08
	LAb 	= $08
	LA 	= $09
	LAs 	= $0A
	LBb 	= $0A
	LB 	= $0B
	C 	= $0C
	Cs 	= $0D
	Db 	= $0D
	D 	= $0E
	Ds 	= $0F		
	Eb 	= $0F
	E 	= $10
	F 	= $11
	Fs 	= $12
	Gb 	= $12
	G 	= $13	;NOTES (CENTER AROUND INSTRUMENT RANGE)
	Gs 	= $14
	Ab 	= $14
	Ax 	= $15	;SPECIAL CASE.  A WAS REGISTER INDICATOR.  USE Ax.
	As 	= $16
	Bb 	= $16
	B 	= $17
	HC 	= $18
	HCs 	= $19	;s MEANS SHARP (#)
	HDb 	= $19	;b MEANS FLAT
	HD 	= $1A
	HDs 	= $1B
	HEb 	= $1B
	HE 	= $1C
	HF 	= $1D
	HFs 	= $1E
	HGb 	= $1E
	PAUSE 	= $1F

	N16 	= 0	;NOTE DURATIONS.  USE BY ADDING (Gs+N16)
	N8 	= $20	;N8 = B'00100000
	N4 	= $40	;N4 = B'01000000
	N2 	= $60	;N2 = B'01100000
	N1 	= $80	;N1 = B'10000000

	BASE_HARPSI 	= %10100000
	HARPSI 		= %10100001
	HIGH_HARPSI 	= %10100010
	BASE_STRING 	= %10100011
	STRING 		= %10100100
	HIGH_STRING 	= %10100101
	BASE_ELECPIANO 	= %10100110
	ELECPIANO 	= %10100111
	HIGH_ELECPIANO 	= %10101000	;INSTRUMENT SELECT COMMANDS
	BASE_SLIDER 	= %10101001
	SLIDER 		= %10101010
	HIGH_SLIDER 	= %10101011
	BASE_BEE 	= %10101100
	BEE 		= %10101101
	HIGH_BEE 	= %10101110
	BASE_PIANO 	= %10101111
	PIANO 		= %10110000
	HIGH_PIANO 	= %10110001
	BASE_ARCADE 	= %10110010
	ARCADE 		= %10110011
	HIGH_ARCADE 	= %10110100


	VOICE0 = %11100000
	VOICE1 = %11100001	;USED TO SELECT A REGISTER SET (VOICE).
	VOICE2 = %11100010
	VOICE3 = %11100011

	REPLAY = %11100100	;USED TO REPEAT THE SOUND STRING OR END IT.
	ENDPLAY = %11101000

	LOADREG0 = %11101100
	LOADREG1 = %11101101	;USED TO HARD CODE LOADING OF REGISTERS
	LOADREG2 = %11101110	;IN CURRENTLY SELECTED REGISTER SET (VOICE).
	LOADREG3  = %11101111

	STOPVOICE = %11110000
	STARTVOICE = %11110100 	;USED TO SILENCE OR ACTIVATE A VOICE

	COMPLEX = %11111000	;USED TO SELECT THE COMPLEX SOUND GENERATOR

	LOADALL = %11111001	;USED TO SPECIFY LOADING ALL 4 REGS

;THIS ROUTINE WILL PLAY (ACTIVATE) THE SOUND STRUCTURE POINTED TO BY
;Y:X.  THE SLOT TO PLAY IT IN IS PASSED IN A.  A RETURNS Z IF SUCCESS
;AND NZ IF FAILURE.  THE VALUES FOR A ARE:

;0 AND Z IF SUCCESS.
;-1 IF THE SOUND SLOT # WAS INVALID (OVER RANGE).
;1 IF THE SLOT WAS ALREADY IN USE (USE SILENCE TO FREE THE SLOT).

PLAY:  	STX	SUBSVAR1
	STY	SUBSVAR2	;SAVE ENTRY POINTERS
	JSR	SNDINDX		;IN RANGE?
	BEQ	P10
	RTS

P10:	LDA	SND_RAM+SF,X	;IN USE?
	BPL	P20
	LDA	#1		;IF IT IS, RETURN 1
	RTS

P20:	LDA	#1
	STA	SND_RAM+ST,X	;SET NEXT NMI TO ACTIVATE SOUND
	LDA	#0
	STA	SND_RAM+SI,X	;SET INSTRUMENT 0 AS DEFAULT
	LDA	SUBSVAR1
	STA	SND_RAM+SBL,X
	STA	SND_RAM+SOL,X	;SET LOW OFFSET
	LDA	SUBSVAR2
	STA	SND_RAM+SBH,X
	STA	SND_RAM+SOH,X	;SET HIGH OFFSET
	LDA	#$C0
	STA	SND_RAM+SF,X	;SET AS ACTIVE SOUND STRUCTURE BUT NO REG.
	RTS

;THIS ROUTINE IS USED AT BOOT TO ZERO THE SOUND CONTROL RAM. SILENCE
;CANNOT BE USED BECAUSE THE DATA WILL BE INTERPRETED AND IT IS INVALID AT
;THAT TIME.

ZERO_SOUND:
 	LDA	#0
	TAX
ZS10:	STA	SND_RAM,X
	INX
	CPX	#SNDMEM		;SEE IF DONE
	BNE	ZS10
	RTS

;THIS ROUTINE WILL SILENCE (FREE UP) THE SOUND SLOT SPECIFIED BY A.
;IT IS OK TO SILENCE A SOUND THAT IS NOT ACTIVE.  ON RETURN A=0 AND Z 
;IF SUCCESS OR A=-1 AND NZ IF INVALID SLOT #.

SILENCE:
	CMP	#-1		;SILENCE ALL?
	BNE	S10

ALLSILENCE:
	LDA	#0
S5:	PHA
	JSR	SILENCE		;IF SO, LOOP WITH ALL VALUES
	BNE	S7
	PLA
	CLC
	ADC	#1
	JMP	S5
S7:	PLA
	LDA	#0		;AND RETURN OK.
	RTS

S10:	JSR	SNDINDX
	BEQ	S20	
	RTS			;IF BAD INDEX, RETURN -1

;INTERNAL CALL LOCATION IF X HAS A VALID SLOT NUMBER TO SILENCE.

S20:  	LDA	SND_RAM+SF,X	;GET THE FLAG BYTE
	BPL	S50		;SKIP IF NOT IN USE

;THIS SLOT WAS ACTIVE.  IF IT WAS NOT ACTUALLY PLAYING WE ARE DONE BUT
;IF IT WAS PLAYING, WE MIGHT HAVE TO REACTIVATE ANOTHER SUSPENDED SOUND
;SLOT.  WE SCAN THE LIST FROM THE TOP DOWN AND ONLY REACTIVATE THE FIRST
;WE FIND.

	TAY			;SAVE A COPY
	AND	#$60		;SEE IF NOT ASSIGNED OR IF SUSPENDED
	BEQ	S25		;SKIP IF TRULY ACTIVE
	LDA	#0
	STA	SND_RAM+SF,X	;IF INACTIVE, JUST FREE IT UP
	JMP	S50		;IF THIS ONE'S INACTIVE, IT DIDN'T SUSPEND ANY

S25:  	JSR	DISABLE_VOICE	;IF ACTIVE, DISABLE IT'S VOICE
	LDA	SND_RAM+SF,X	;GET BACK IT'S FLAG
	PHA			;SAVE THE FLAG
	LDA	#0
	STA	SND_RAM+SF,X	;FREE UP THIS SOUND STRUCTURE
	PLA
	AND	#$1F		;KEEP BASE OF REGISTERS IN USE
	STA	SUBSVAR1	;SAVE HERE FOR COMPARE TO ONES WE FIND

	LDX	#0		;START AT LOWEST SLOT

S30:	TXA
	PHA
	LDA	SND_RAM+SF,X	;GET ITS FLAG BYTE
	BPL	S42		;IF NOT IN USE, SKIP IT

	AND	#$20		;SEE IF SUSPENDED
	BEQ	S42		;WE DON'T CARE UNLESS IT IS
	LDA	SND_RAM+SF,X
	AND	#$1F		;GET THE VOICE IT WAS USING
	EOR	SUBSVAR1	;SEE IF SAME AS OURS
	BNE	S42		;IF NOT, WE DON'T CARE
	PLA			;IF IT WAS, DISCARD SLOT INDEX
	JSR	INITSND		;AND INITIALIZE IT
	LDA	SND_RAM+SF,X
	AND	#$DF
	STA	SND_RAM+SF,X	;AND MARK AS NOT SUSPENDED ANY MORE
	JMP	S50

S42:	PLA
	CLC
	ADC	#SND_WIDE
	TAX
	CMP	#SND_WIDE*SNDSLOTS	;SEE IF DONE WITH LIST
	BCC	S30			;DO NEXT
	JMP	S50

S45:	PLA			;IF LIST END, DONE

S50:	LDA	#0
	RTS

;THIS ROUTINE WILL CHECK THE STATUS OF THE SOUND SLOT IN A.  ON RETURN:
;A=0 AND Z IF NOT IN USE
;A=1 AND NZ IF IN USE
;A=-1 AND NZ IF INVALID SLOT #

PLAYING:
	JSR	SNDINDX		;IN RANGE?
	BNE	PL10
	LDA	SND_RAM+SF,X	;IN USE?
	BMI	PL20
	LDA	#0
PL10:	RTS
PL20:	LDA	#1		;IF IT IS, RETURN 1
	RTS

;THIS ROUTINE IS CALLED TO INITIALIZE A NEW BACKGROUND OR TO RAPIDLY
;MOVE TO A NEW LOCATION IN AN EXISTING BACKGROUND.  IT FILLS THE ENTIRE
;SCREEN BUFFER IN 1 PASS AND THUS PRODUCES A QUICK FLICKER ON THE SCREEN.
;TYPICALLY IT IS ONLY USED TO BOOT A SCREEN AND NOT TO SCROLL IT.

;TO USE THIS ROUTINE, SET XBACK (WORD) TO THE DESIRED X PIXEL LOCATION
;IN THE BACKGROUND.  SET YBACK (WORD) TO THE DESIRED Y PIXEL LOCATION.
;POINT Y:X (Y HIGH BYTE, X LOW BYTE) TO THE BACKGROUND TO BE USED.

;OUT OF RANGE X AND Y LOCATIONS WILL BE CORRECTED AND THIS FACT CAN
;BE USED TO MOVE TO THE BOTTOM OR END OF A SCREEN.

INITBACK:
	JSR	ALLOW_WRITES

	STX	BACKBASE
	STY	BACKBASE+1	;SET POINTER TO BACKGROUND DATA

	LDA	#-1
	STA	BACKVALID	;ENABLE BACKGROUND SCROLL CREATION

	JSR	WRITE_SCBUF	;CLEAR THE BUFFER WE NEED

	TESTIT = $3C0

;IFDEF( `PAGED', `
.ifdef  PAGED
	LDA	BACKBASE+1	;SEE IF IN SECOND PAGE
	BMI	IB20
	LDA	#2
	STA	TESTIT
	JSR	CALL_GETWIDE 	;IF IN SECOND PAGE, GET ROW FROM THERE.
	LDA	#0
	STA	TESTIT
	JMP	IB25
.endif

IB20:	LDY	#0
	LDA	(BACKBASE),Y
	STA	BACKSIZE
	INY
	LDA	(BACKBASE),Y
	STA	BACKWIDE
	CLC
	ADC	#3		;ROUND WIDTH UP TO MAKE PALETTE WIDTH
	ROR	A
	LSR	A		;AND DIVIDE BY 4 TO GET PALETTE WIDTH
	STA	BPWIDE

	INY
	LDA	(BACKBASE),Y
	STA	BACKHIGH	;GET THE 3 BACKGROUND PARAMETERS

IB25:	CLC
	LDA	BACKBASE
	ADC	#3
	STA	BACKBASE
	LDA	BACKBASE+1
	ADC	#0
	STA	BACKBASE+1	;MAKE POINTER POINT TO THE ACTUAL DATA ROWS

	LDA	BACKWIDE	;GET CURRENT WIDTH
	SEC
	SBC	#32		;MAKE LEFTMOST VALUE ALLOWED FOR A DATA COL
	BCS	IB30
	LDA	#0		;IF LESS THAN SCREEN WIDTH, SET TO 0
IB30:	STA	END_COL

	LDA	BACKHIGH	;GET CURRENT HEIGHT
	SEC
	SBC	#30		;MAKE TOPMOST VALUE ALLOWED FOR A DATA ROW
	BCS	IB40
	LDA	#0		;IF LESS THAN SCREEN HEIGHT, SET TO 0
IB40:	STA	END_ROW

	LDX	BACKWIDE
	LDY	BACKHIGH
	JSR	MUL		;MAKE A POINTER TO THE PALETTE INFO
	CLC
	TXA
	ADC	BACKBASE
	STA	BPBASE
	TYA
	ADC	BACKBASE+1
	STA	BPBASE+1	;POINT DIRECTLY TO IT IN MEMORY

	JSR	FIXSCROLL	;FIX THE USER'S WINDOW VALUES
		
;BUILD THE ROWS NEEDED TO FILL THE SCREEN.  WE USE THE SAME ROUTINE USED
;TO SCROLL BUT CALL IT UNTIL DONE.

	LDA	#30		;GET LOOP COUNT
	CMP	BACKHIGH	;MAKE SURE WE HAVE THAT MUCH
	BCC	IB50
	LDA	BACKHIGH	;IF NOT, USE MAX WE HAVE

IB50:	LDY	TMP_NMI7
	LDX	TMP_NMI8	;AND STARTING ROW, COL

IB60: 	PHA
	TXA
	PHA
	TYA
	PHA

;IF WE HAVE A PAGED ROM WE MUST DO THINGS DIFFERENTLY.  IF OFFSET <$8000
;ITS IN THE SECOND PAGE.

;IFDEF( `PAGED', `
.ifdef  PAGED
	LDA	BACKBASE+1	;SEE IF IN SECOND PAGE
	BMI	IB62
	LDA	#3
	STA	TESTIT
	JSR	CALL_ROW2 	;IF IN SECOND PAGE, GET ROW FROM THERE.
	LDA	#0
	STA	TESTIT
	JMP	IB65
.endif

IB62:	JSR	BUILD_ROW	;GET DATA ROW INTO SCBUF. 
IB65:	JSR	WRITE_SCBUF
	PLA
	TAY
	PLA
	TAX
	PLA
	INY		;MOVE TO NEXT ROW
	SEC
	SBC	#1
	BNE	IB60		;DO ALL 30 ROWS

;MAKE THE SCROLL VALUE FROM THE CURRENT WINDOW LOCATIONS

	LDA	XBACK
	STA	CURX
	LDA	XBACK+1
	STA	CURX+1

	LDA	YBACK
	STA	CURY
	LDA	YBACK+1
	STA	CURY+1		;SET WINDOW AS CURRENT LOCATION

	JSR	MAKE_SCROLL	;CONVERT IT INTO SCROLL VALUES

;THIS SUB CAN BE CALLED TO RE-ENABLE NMI.  IT DOES NOT RE-ENABLE VIDEO.
;THE NEXT NMI WILL DO THAT.

RESUME_NMI:			
	LDA	REG2000
	ORA	#$80
	STA	$2000		;REENABLE NMI AND LET IT REENABLE VIDEO
	RTS


;THIS SUB WILL DISABLE NMI, WAIT FOR VERTICAL RETRACE, AND THEN DISABLE
;VIDEO.  IT SHOULD BE USED IN PREP FOR A SCREEN WRITE.

ALLOW_WRITES:
	LDA	REG2000
	STA	$2000		;DISABLE NMI
	JSR	VERT_WAIT	;WAIT TO PREVENT SCREEN FLASH
	LDA	#6
	STA	$2001		;ENABLE SCREEN WRITES, DISABLE VIDEO
	RTS

;THIS ROUTINE WILL SCROLL A BACKGROUND THAT HAS BEEN INITIALIZED WITH INITBACK.
;SET XBACK AND YBACK (BOTH WORDS) AND CALL THIS ROUTINE.  THE VALUES
;YOU PUT IN XBACK AND YBACK ARE FOR YOUR OWN USE AND WILL NOT BE CHANGED
;BY CALLING THIS ROUTINE OR BY CALLING INITBACK UNLESS THEY ARE INVALID
;AND NEED TO BE ADJUSTED.

SCRLBACK:
	LDA	BACKVALID
	BEQ	SCRL10
	;LDA	#B'11			;LOW=X SCROLL, HIGH=Y SCROLL.
        LDA	#$3			;LOW=X SCROLL, HIGH=Y SCROLL.
	STA	MOVEBACK		;JUST SET A FLAG
SCRL10:	RTS

;THIS ROUTINE WILL KILL A BACKGROUND INITIALIZED WITH INITBACK AND WILL
;THUS RESET THE SCROLL TO 0.  IT IS USED TO TAKE MANUAL CONTROL OF THE
;BACKGROUND.  ONCE YOU HAVE CALLED THIS ROUTINE, THE SCROLL REGISTER VALUES
;USED BY NMI WILL NOT BE CHANGED.

KILLBACK:
	LDA	#0
	STA	BACKVALID
	STA	XSCROLL		;ZERO X SCROLL
	LDA	YADJ
	STA	YSCROLL		;BUT USE USER ADJUSTMENT FOR Y SCROLL
	STA	CURX
	STA	CURY		;ZERO BACKGROUND SCROLL LOW VALUES FOR PUTSPRT
	LDA	REG2000
	AND	#$FE
	STA	REG2000		;SET PAGE 0
	RTS	

;THIS ROUTINE WILL CHECK TO SEE IF GIVEN NEW SCROLL VALUE FOR A BACKGROUND
;PUTS A GIVEN SPRITE ON TOP OF "SOLID" DATA.  IT SHOULD BE USED ONLY
;FOR SPRITES WHO HAVE BEEN SET TO USE THE SOLID FEATURE WITH A CALL TO
;THE "SOLID" ROUTINE.  LOAD XBACK AND YBACK WITH THE SAME VALUES YOU WOULD
;USE FOR A CALL TO "SCRLBACK".  LOAD A WITH THE SLOT # OF THE SPRITE.
;ON RETURN, IF Z THEN THE SCROLL IS OK.  IF NZ THEN THE SPRITE WOULD BE
;ON TOP OF SOLID DATA.  YOU WILL PROBABLY WANT TO SAVE THE OLD VALUES
;FOR XBACK AND YBACK AND RESTORE THEM IF NZ.

CHECKBACK:
	TAX		;SAVE SLOT #
	LDA	CURX
	PHA
	LDA	CURX+1
	PHA
	LDA	CURY
	PHA
	LDA	CURY+1
	PHA		;SAVE CURRENT SCROLL LOCATIONS

	LDA	XBACK	
	STA	CURX
	LDA	XBACK+1
	STA	CURX+1
	LDA	YBACK
	STA	CURY
	LDA	YBACK+1
	STA	CURY+1	;SET CURRENT LOCATION TO SAME AS THIS ONE.

	TXA
	LDX	#0
	LDY	#0
	JSR	MOVESPRT	;SEE IF WE COULD MOVE THERE
	TAY			;AND SAVE RETURN REG

	PLA
	STA	CURY+1
	PLA
	STA	CURY  
	PLA
	STA	CURX+1
	PLA
	STA	CURX  		;RESTORE LOCATIONS
	TYA
	RTS

;THIS ROUTINE WILL ACTIVATE A BACKGROUND PALETTE.  POINT Y TO THE
;HIGH OFFSET AND X TO THE LOW AND CALL.

;THIS ROUTINE SHOULD ONLY BE CALLED FROM AN NMI LEVEL OR FROM A MAIN
;LEVEL WHILE NMI IS DISABLED.  OTHERWISE THERE IS A SMALL CHANCE OF
;MESSING UP A SPRITE PALETTE.

BACKPAL:
	LDA	#1
	ORA	NEW_PAL
	STA	NEW_PAL		;SET FLAG TO INIT PALETTE DURING NMI
	STX	BPAL_BASE
	STY	BPAL_BASE+1	;SET BASE OF PALETTE INFO
	RTS

;THIS ROUTINE WILL ACTIVATE A SPRITE PALETTE.  POINT Y TO THE
;HIGH OFFSET AND X TO THE LOW AND CALL.

;THIS ROUTINE SHOULD ONLY BE CALLED FROM AN NMI LEVEL OR FROM A MAIN
;LEVEL WHILE NMI IS DISABLED.  OTHERWISE THERE IS A SMALL CHANCE OF
;MESSING UP A BACKGROUND PALETTE.

SPRITEPAL:
	LDA	#2
	ORA	NEW_PAL
	STA	NEW_PAL		;SET FLAG TO INIT PALETTE DURING NMI
	STX	SPAL_BASE
	STY	SPAL_BASE+1	;SET BASE OF PALETTE INFO
	RTS

;THIS ROUTINE WILL SELECT THE CHARACTER SET TO BE USED BY BACKGROUNDS.
;IT SELECTS BOTH THE ROM PAGE IN VIDEO AND ALSO SETS BITS NEEDED IN
;REG 2000 TO FORCE USE OF UPPER OR LOWER SET.  THIS ROUTINE DOES
;NOT CHECK FOR OVERLAP WITH THE SPRITE SET OR FOR SELECTION OF A ROM
;BANK WHICH IS NOT THE SAME AS THAT IN USE BY THE SPRITES.

;ON ENTRY, A HAS THE DESIRED CHARACTER SET (0-15) TO BE USED.

SELBKSET:
	PHA			;SAVE DESIRED PAGE
	AND	#1		;KEEP UPPER PAGE SELECT BIT
	TAX			;PUT INTO REG WE CAN USE	
	LDA	REG2000
	AND	#$EF		;TURN OFF BACKGROUND UPPER PAGE SELECT
	DEX			;SEE IF UPPER BIT SELECTED
	BNE	SBK10
	ORA	#$10		;IF BIT SET, OR IT IN
SBK10:	STA	REG2000
	PLA	
	JSR	SEL_VPAGE
	RTS	

;THIS ROUTINE WILL SELECT THE CHARACTER SET TO BE USED BY THE SPRITES.
;IT FOLLOWS THE SAME RULES AS FOR THE BACKGROUND.

SELSPSET:
	PHA			;SAVE DESIRED PAGE
	AND	#1		;KEEP UPPER PAGE SELECT BIT
	TAX			;PUT INTO REG WE CAN USE	
	LDA	REG2000
	AND	#$F7		;TURN OFF BACKGROUND UPPER PAGE SELECT
	DEX			;SEE IF UPPER BIT SELECTED
	BNE	SPS10
	ORA	#8		;IF BIT SET, OR IT IN
SPS10:	STA	REG2000
	PLA	
	JSR	SEL_VPAGE
	RTS	

;THIS ROUTINE WILL PUT DOWN AN OBJECT GENERATED WITH THE COLOR DREAMS
;DRAWING PROGRAM.  THE OBJECT MUST BE A BACKGROUND OBJECT, NOT A SPRITE
;BLOCK.  YOU SPECIFY A TEXT ROW AND COLUMN POSITION WITHIN THE
;30 ROWS HIGH (0-29) SCREEN BY 64 COLUMNS (0-63) WIDE.  THE COLUMN
;LOCATION IS A LOCATION GENERATED BY COMBINING THE FIRST SCREEN PAGE
;WITH THE SECOND SO THAT THE FIRST COLUMN OF THE SECOND SCREEN PAGE IS
;CONSIDERED TO BE 1 COLUMN TO THE RIGHT OF THE LAST COLUMN OF THE FIRST
;PAGE (JUST AS IS DONE TO SCROLL).

;ON ENTRY, Y:X POINTS TO THE OBJECT STRUCTURE (Y=HIGH BYTE OFFSET, X=LOW).
;LOAD XOBJ WITH THE DESIRED COLUMN LOCATION AND YOBJ WITH THE DESIRED ROW
;(BOTH BYTES).    ON RETURN, IF A=0 AND Z SUCCESS.  IF A<>0 THEN
;BUSY (YOU SHOULD RECALL, THE REGS ARE STILL SET UP).  DON'T RECALL
;IN A HARD LOOP SINCE IT CAN'T POSSIBLY GET UNBUSY UNTIL THE NEXT NMI.  

;THIS ROUTINE MUST BE CALLED FROM NMI LEVEL ONLY.  IT CANNOT BE USED FROM
;THE NON-NMI LEVEL AND THIS ALSO EXCLUDES BOOT TIME.

PUTOBJ:	

	STY	SUBSVAR2
	STX	SUBSVAR1	;SAVE POINTER TO THE OBJECT

	JSR	OBJ_BYTES	;SEE HOW MUCH IT TAKES
	STA	SUBSVAR3	;SAVE IT HERE
	JSR	GET_ROOM	;SEE IF ENOUGH ROOM FOR MAX SIZE.
	CMP	SUBSVAR3	;ENOUGH?
	BCS	PO20
	LDA	#-1
	RTS

;HAVE ENOUGH ROOM.  OK TO BUILD THE OBJECT.

PO20:	LDY	YOBJ
	LDX	#32
	JSR	MUL		;MAKE OFFSET TO SCREEN
	LDA	XOBJ
	AND	#$1F		;MASK OFF PAGE BIT
	JSR	ADD_WORD	;DON'T FORGET COLUMN OFFSET	
	STX	SUBSVAR3	;SAVE LOW BYTE
	STY	SUBSVAR4	;AND TEMPORARILY SAVE HIGH
	LDA	XOBJ
	EOR	#$20
	AND	#$20		;MAKE BASE=20H IF LOW PAGE
	BNE	PO25
	LDA	#$24		;ITS 24 IF PAGE 1
PO25:	CLC
	ADC	SUBSVAR4	;ADD IN HIGH BYTE TO HIGH PAGE OFFSET
	STA	SUBSVAR4	;NOW 3&4 HAVE VID RAM OFFSET

	LDY	#1
	LDA	(SUBSVAR1),Y	;GET WIDTH OF THE OBJECT
	STA	TMP_NMI2	;SAVE HERE
	INY
	LDA	(SUBSVAR1),Y	;GET HEIGHT
	STA	TMP_NMI1	;SAVE HERE

	LDA	#$20		;GET AMOUNT TO CORRECT FOR NEXT ROW
	STA	TMP_NMI3	;SAVE HERE

	LDA	#3
	CLC
	ADC	SUBSVAR1
	STA	SUBSVAR1
	BCC	PO40
	INC	SUBSVAR2	;CORRECT POINTER TO MAKE IT = DATA

;(SUBSVAR1) = DATA, SUBSVAR3 & 4 = SCREEN, TMP_NMI1=ROWS, TMP_NMI2=COLS,
;TMP_NMI3=NEXT ROW.

PO40:	JSR	WRITE_BLOCK	;WRITE OUT THE DATA BLOCK

;NOW SUBSVAR1 & 2 POINT TO THE PALETTE DATA, TMP_NMI1 & 2 STILL HAVE THE
;ROWS AND COLS.  WRITE OUT THE PALETTE DATA.

	LDA	YOBJ
	LSR	A
	LSR	A
	TAY			;MAKE ROW/4
	LDX	#8
	JSR	MUL		;MAKE OFFSET TO PALETTE RAM ROW

	LDA	XOBJ
	AND	#$1F		;MASK OFF PAGE BIT
	LSR	A
	LSR	A		;MAKE COL/4
	JSR	ADD_WORD	;ADD IN PALETTE BYTE OFFSET IN THIS ROW
	STX	SUBSVAR3	;SAVE LOW BYTE
	STY	SUBSVAR4	;AND TEMPORARILY SAVE HIGH

	LDY	#$23		;ASSUME THIS IS HIGH OFFSET OF PAL RAM
	LDX	#$C0		;THIS IS ALWAYS LOW
	LDA	XOBJ
	AND	#$20		
	BEQ	PO75
	LDA	#$27		;ITS 27 IF PAGE 1
PO75:  	TXA
	CLC
	ADC	SUBSVAR3
	STA	SUBSVAR3
	TYA
	ADC	SUBSVAR4	;MAKE POINTER DIRECTLY TO PAL RAM
	STA	SUBSVAR4

	LDA	TMP_NMI1	;GET ROWS
	CLC
	ADC	#3		;ROUND UP TO GET PALETTE BYTE ROWS
	LSR	A
	LSR	A		;MAKE NUMBER OF PALETTE ROWS
	STA	TMP_NMI1	

	LDA	TMP_NMI2
	CLC
	ADC	#3		;ROUND UP FOR LAST BYTE
	LSR	A
	LSR	A
	STA	TMP_NMI2	;SAVE BYTES PER PALETTE ROW

	LDA	#8		;GET AMOUNT TO CORRECT FOR NEXT ROW
	STA	TMP_NMI3	;SAVE HERE

	JSR	WRITE_BLOCK	;WRITE OUT THE BLOCK OF PALETTE INFO
	RTS

;THIS SUBROUTINE WILL WRITE OUT A BLOCK OF DATA THAT HAS BEEN SET UP
;WITH THE FOLLOWING VARIABLES: (SUBSVAR1) = DATA, SUBSVAR3 & 4 = SCREEN, 
;TMP_NMI1=ROWS, TMP_NMI2=COLS, TMP_NMI3=NEXT ROW CORRECTION.  

;THIS ROUTINE IS INTENDED FOR USE BY PUTOBJ AS A SUB.  IT USES TMP_NMI4 & 5.

WRITE_BLOCK:
	LDA	TMP_NMI1
	STA	TMP_NMI4	;MAKE A WORKING ROWS COUNT
	LDX	SCCNT		;POINT TO THE BUFFER SPOT TO USE

WB85:	LDA	SUBSVAR4
	STA	SCBUF,X
	INX			;STORE HIGH ADDRESS
	LDA	SUBSVAR3
	STA	SCBUF,X
	INX			;STORE LOW ADDRESS
	LDA	TMP_NMI2	;GET WIDTH
	STA	TMP_NMI5	;MAKE COPY FOR LOOP
	STA	SCBUF,X
	INX			;STORE IN BUFFER TO MAKE FLAG BYTES FOR WRITE
	
	LDY	#0
WB90:	LDA	(SUBSVAR1),Y
	STA	SCBUF,X		;WRITE OUT A BYTE FOR THIS ROW
	INX
	INY
	DEC	TMP_NMI5	;DEC OUR ROW LENGTH LOOP COUNTER
	BNE	WB90

	TYA
	CLC
	ADC	SUBSVAR1	;ADJUST DATA POINTER
	STA	SUBSVAR1
	BCC	WB95
	INC	SUBSVAR2
WB95:	LDA	SUBSVAR3
	CLC
	ADC	TMP_NMI3	;AND ADJUST SCREEN POINTER
	STA	SUBSVAR3
	BCC	WB100
	INC	SUBSVAR4
WB100:	DEC	TMP_NMI4	;COUNT 1 MORE ROW
	BNE	WB85
	STX	SCCNT
	RTS

;THIS ROUTINE WILL INITIALIZE A BLOCK OF SPRITES OR AN ANIMATION.
;POINT Y:X TO THE STRUCTURE, SET A TO THE DESIRED SLOT IN THE
;SPRITE/ANIMATION RAM AND CALL.  THE STRUCTURE SHOULD BE ONE 
;CREATED WITH THE COLOR DREAMS DRAWING PROGRAM.  BACKGROUND 
;ANIMATION IS ALSO ALLOWED.  THIS CALL DOES NOT POSITION THE SPRITE
;BLOCK OR OBJECT ANIMATION, CALL PUTSPRT TO DO THAT.

;SPRITE STRUCTURES HAVE A BUILT IN BASE SPRITE NUMBER AS WELL AS
;A 1 BY 2 MODE FLAG.  THE 1 BY 2 MODE FLAG IS HONORED IMMEDIATLY ON
;MAKING THIS CALL.  THE APPROPRIATE REGISTER WILL BE SET INTO 1 BY 2
;MODE.  THE BASE SPRITE NUMBER IS USED AS A REQUEST ONLY.  IF THE REQUESTED
;SPRITES ARE OCCUPIED THEN THE NEXT HIGHER SPRITES WILL BE CHECKED UNTIL
;AN UNUSED BLOCK OF THE NECESSARY SIZE IS FOUND (THE SEARCH WILL WRAP AROUND
;IF NECESSARY).

;SINCE THE 1 BY 2 MODE FLAG IS HONORED IMMEDIATLY, DON'T CALL TO INIT
;SPRITES OF DIFFERENT HEIGHTS OR THE LAST INITIALIZED WILL BE THE ONE
;HONORED.

;ALL FRAMES IN THE ANIMATION MUST BE THE SAME WIDTH AND HEIGHT OR
;THIS ROUTINE WILL FAIL.   ALSO, THE DRAWING PROGRAM ALLOWS ANIMATION
;FRAMES TO NOT EXIST.  THIS ROUTINE CANNOT SUPPORT THAT CAPABILITY IN
;THE SAME MANNER SINCE THE ASSEMBLER TAKES THE ANIMATION NAME AND ATTEMPTS
;TO USE IT AS A LABEL DURING ASSEMBLY.  IF YOU WANT TO USE AN ANIMATION
;BEFORE ALL FRAMES EXIST, USE A TEXT EDITOR TO DUPLICATE THE NAMES OF
;OTHER FRAMES AND PUT THEM WHERE THE NON-EXISTING FRAMES APPEAR IN
;THE DRAW2ASM OUTPUT.

;ON RETURN FROM THIS CALL, IF THE SLOT WAS SUCCESSFULLY INITIALIZED THEN A=0 
;AND Z.  IF NZ THEN THE CALL WAS NOT SUCCESSFUL AND A HAS AN ERROR CODE:
;-1 IF THE ANIMATION SLOT # WAS INVALID (OVER RANGE).
;1 IF THE SLOT WAS ALREADY IN USE.
;2 IF NO CONTIGUOUS SPRITES WERE AVAILABLE TO BUILD THIS SPRITE BLOCK
;3 IF OBJECT ANIMATION IS TOO BIG.  IT IS TOO BIG IF:
;		(3+WIDTH)*ROWS + ((WIDTH+3)\4+3)*ROWS > 64

;THIS ROUTINE MUST BE CALLED FROM 1 LEVEL ONLY.  CALL EITHER FROM NMI
;LEVEL OR FROM NON-NMI LEVEL BUT DON'T MIX IN THE SAME GAME OR ELSE
;YOU MIGHT MISALLOCATE DUE TO INTERRUPT DURING ALLOCATION.

INITSPRT:
	
	STX	SUBSVAR1
	STY	SUBSVAR2

	JSR	ANIMINDX
	BEQ	II20
	RTS			;IF BAD INDEX, RETURN TO CALLER.

II20:	LDA	ANIM_RAM+FB,X	;GET THE ANIMATION FLAG
	BEQ	II30		;IF FREE, OK TO CONTINUE
	LDA	#1		;IF NOT FREE, RETURN 1.
	RTS

II30:  	LDA	SUBSVAR1
	STA	ANIM_RAM+PTRL,X
	LDA	SUBSVAR2       	;GET BACK INDEXES
	STA	ANIM_RAM+PTRH,X	;PUT MEMORY LOCATION INTO STRUCTURE

	LDA	#0
	STA	ANIM_RAM+AF,X	;ZERO THE AUX FLAGS
	
;GET THE PARTICULARS ABOUT THE SPRITE OR OBJECT STRUCTURE.  IF THE THING
;IS A SIMPLE SPRITE BLOCK THAN THE FIRST BYTE (FLAG BYTE) BIT 40H WILL
;BE OFF.  IF IT'S AN ANIMATION, BIT 40H WILL BE SET AND THE FLAG VALUE
;WILL BE "S" FOR A SPRITE ANIMATION AND "O" FOR AN OBJECT ANIMATION.

	LDY	#0
	LDA	(SUBSVAR1),Y	;GET THE FLAG BYTE
	CMP	#79		;ASCII "O"?
	BNE	II90
	JMP	II200

II90:	CMP	#83		;ASCII "S"
	BEQ	II100		;IF IT IS, GO TO INIT THAT

;ITS JUST A SPRITE BLOCK.  WE MUST SET THE FLAG FOR TYPE TO 1 AND LEAVE
;THE OTHER VARIABLES ALONE.  WE PUT THE TYPE FLAG INTO THE BASE SPRITE FOR
;NOW BECAUSE WE DON'T WANT THE NMI LEVEL TO FIND THIS STRUCTURE VALID UNTIL
;IT IS FULLY INITIALIZED.

	LDA	#$81
	STA	ANIM_RAM+BS,X	;SET AS SIMPLE SPRITE BLOCK
	JMP	II120		;GO SHARE ENDING CODE WITH ANIMATION SETUP.
	
;ITS A SPRITE ANIMATION.

II100:	LDA	#$82
	STA	ANIM_RAM+BS,X	;SET AS SPRITE ANIMATION
	LDA	#0
	STA	ANIM_RAM+FR,X	;ZERO THE FRAME WE ARE CURRENTLY DISPLAYING
	LDY	#2
	LDA	(SUBSVAR1),Y	;GET THE FREQUENCY
	STA	ANIM_RAM+CN,X	;SET INITIAL FREQUENCY
	STA	ANIM_RAM+RL,X	;AND SET RELOAD VALUE
	INY
	LDA	(SUBSVAR1),Y
	INY
	PHA
	LDA	(SUBSVAR1),Y	;GET FIRST ENTRY'S POINTER
	STA	SUBSVAR2
	PLA
	STA	SUBSVAR1	;SET OFFSET FOR SHARED INIT OF FIRST FRAME

;SEE IF WE CAN FIND A SPRITE BLOCK TO USE IT.  (SUBSVAR1) POINTS TO THE
;FIRST FRAME OR TO THE ONLY FRAME IF SPRITE BLOCK.

II120: 	TXA

	PHA			;SAVE THE SLOT INDEX
	LDY	#1
	LDA	(SUBSVAR1),Y	;GET WIDTH
	TAX
	INY
	LDA	(SUBSVAR1),Y	;GET HEIGHT
	TAY
	JSR	MUL		;MAKE NUMBER OF SPRITES USED
	STX	MATH2		;SAVE HERE

	LDY	#0
	LDA	(SUBSVAR1),Y	;GET BASE SPRITE
	AND	#$7F
	ASL	A
	ASL	A		;MAKE #4 POINTER TO THE BLOCK
	STA	MATH1
	TAY

;MATH2 HAS COUNT OF SPRITES NEEDED, Y AND MATH1 HAVE BASE SPRITE TO START FROM.
;BIT 08 IS SET IN SPRITES IN USE, RESET IF AVAILABLE.  WE STILL HAVE THE
;INDEX TO THE SLOT ON THE STACK!


II130:	LDX	MATH2		;GET COUNT TO BE FOUND
	STY	SUBSVAR3	;SAVE INDEX WE WERE CHECKING.

II140:	LDA	SPRAM+2,Y	;GET IN USE FLAG
	STA	SUBSVAR4	;SAVE IN USE FLAG
	INY
	INY
	INY	
	INY			;SKIP THIS SPRITE
	TYA
	EOR	MATH1		;REACHED LIST END?
	BEQ	II145		;IF SO, DIDN'T FIND THE COUNT WE NEEDED.
	LDA	SUBSVAR4	;GET BACK THE IN USE FLAG
	AND	#8		;IN USE?
	BNE	II130		;IF IN USE, MUST SKIP THIS ONE
	DEX
	BNE	II140	
	JMP	II160

II145:	PLA			;DISCARD SLOT #
	LDA	#2		;IF END OF SPRITES AND NOT ENOUGH, RETURN ERR
	RTS

II160:	LDY	SUBSVAR3	;GET BACK BASE SPRITE WE CAN USE
	PLA
	TAX			;GET BACK SLOT INDEX
	LDA	MATH2		;GET BACK NUMBER OF SPRITES USED
	STA	ANIM_RAM+NS,X	;SET INTO STRUCTURE

	LDA	ANIM_RAM+BS,X	;GET FLAG TYPE WE PUT HERE FOR TEMP USAGE
	STA	SUBSVAR3	;SAVE IT
	TYA
	STA	ANIM_RAM+BS,X	;SAVE SPRITE BASE INDEX IN STRUCTURE

;WE HAVE A BASE THAT IS OK.  SET THE SPRITE DOUBLE OR NOT FLAG IN REG2000.

	LDA	REG2000	
	AND	#$DF		;ASSUME NOT DOUBLING SPRITE
	LDY	#0		
	PHA
	LDA	(SUBSVAR1),Y	;GET FLAG FROM THE SPRITE STRUCTURE
	ASL	A
	PLA
	BCC	II180
	ORA	#$20
II180:	STA	REG2000		;SET CONDITION OF SPRITE DOUBLE
	AND	#$20
	STA	DOUBLE_BIT	;AND KEEP A COPY OF IT.

;OK TO MOVE THE TYPE FLAG INTO THE SLOT AND MARK IT IN USE.

	LDA	SUBSVAR3
	STA	ANIM_RAM+FB,X

	LDA	#0
	STA	ANIM_RAM+ABL,X	;RESET BLINK FEATURE

;GET THE FIRST FRAME AND INITIALIZE THIS SPRITE BLOCK.

	JSR	SPFRAME		

	LDA	#0
	RTS

;ITS AN OBJECT ANIMATION.  WE SET THAT UP DIFFERENTLY.  WE ALSO HAVE
;TO CHECK HOW MUCH MEMORY IT TAKES.

II200:	LDA	#0
	STA	ANIM_RAM+FR,X	;ZERO THE FRAME WE ARE CURRENTLY DISPLAYING
	STA	ANIM_RAM+BS,X	;AND FOR ERROR RECOVERY, ZERO X AND Y LOCATION
	LDY	#2
	LDA	(SUBSVAR1),Y	;GET THE FREQUENCY
	STA	ANIM_RAM+CN,X	;SET INITIAL FREQUENCY
	STA	ANIM_RAM+RL,X	;AND SET RELOAD VALUE
	STX	SUBSVAR3	;SAVE SLOT

	INY
	LDA	(SUBSVAR1),Y	;GET LOW OFFSET OF FIRST FRAME
	TAX
	INY
	LDA	(SUBSVAR1),Y	;GET HIGH
	STX	SUBSVAR1
	STA	SUBSVAR2	;POINT TO A FRAME OF IT

 	JSR	OBJ_BYTES
	BCS	II209
	BMI	II209
	CMP	#SCSIZE		;MAKE SURE SIZE CAN FIT IN SCBUF
	BEQ	II210
	BCC	II210

II209:	LDA	#3		;IF NOT, RETURN FAILURE
	RTS

II210: 	LDX	SUBSVAR3	;GET BACK SLOT POINTER
	STA	ANIM_RAM+NS,X	;STORE THE LENGTH REQUIRED TO WRITE DATA OUT.
	LDA	#$83		;SET FOR OBJECT ANIMATION BUT NOT POSITIONED.
	STA	ANIM_RAM+FB,X	
	LDA	#0
	RTS

;THIS ROUTINE WILL POSITION A BLOCK OF SPRITES OR AN OBJECT ANIMATION
;THAT WAS PREVIOUSLY INITIALIZED WITH A CALL TO INITSPRT.  WHEN INITSPRT
;IS CALLED, NO POSITIONING TAKES PLACE.  IF THE STRUCTURE IS AN ANIMATION,
;THE FRAME COUNTING WILL BE ACTIVATED AND CONTINUE EVEN THOUGH THE
;STRUCTURE IS "OFF SCREEN".  YOU MAY CALL HERE TO POSITION OR REPOSITION
;AS OFTEN AS DESIRED WITHOUT UPSETTING THE CURRENT ANIMATION FRAME.

;THE ALIGNMENT ANIMATION FEATURE IS SUPPORTED BY THIS CALL AND SINCE
;MOVESPRT CALLS THIS ROUTINE, MOVESPRT ALSO SUPPORTS IT.  IN THIS MODE
;(ACTIVATED BY CALLING ALIGNANIM) THE CURRENT ANIMATION FRAME WILL BE
;SELECTED BASED ON THE SCREEN AND BACKGROUND SCROLL POSITIONS.

;LOAD A WITH THE ANIMATION SLOT TO AFFECT, X WITH THE DESIRED COLUMN
;(PIXEL IF SPRITE, TEXT COLUMN IF OBJECT) AND LOAD Y WITH THE DESIRED ROW.

;ON RETURN, IF A=0 AND Z THEN SUCCESS.  IF NZ THEN A=-1 IF INVALID SLOT
;AND A=1 IF UNUSED SLOT.  

PUTSPRT:
	STX	SUBSVAR3
	STY	SUBSVAR4	;SAVE DESIRED X AND Y LOCATION
	JSR	ANIMINDX	;SEE IF VALID SLOT NUMBER
	BEQ	PU20
	RTS

PU20:  	LDA	ANIM_RAM+PTRL,X	
	STA	SUBSVAR1
	LDA	ANIM_RAM+PTRH,X
	STA	SUBSVAR2	;ASSUME DIRECT POINTER STORED IN SPRITE SLOT
	LDA	ANIM_RAM+FB,X	;GET TYPE OF STRUCTURE
	AND	#$7F		;REMOVE NOT POSITIONED BIT
	STA	ANIM_RAM+FB,X	;PUT BACK
	AND	#3
	BEQ	PU25		;IF NOT IN USE, BAD TYPE
	CMP	#3		;SEE IF OBJECT OR SPRITE
	BNE	PU21
	JMP	PU100		;SKIP IF OBJECT ANIMATION

PU21:	CMP	#1
	BEQ	PU30		;IF JUST SPRITE, OUR PTR IS GOOD
	LDY	#1
	LDA	(SUBSVAR1),Y	;ASSUME SPRITE ANIMATION, GET FRAMES IN CASE
	STA	SUBSVAR5	;OF UPDATE BY SCREEN ALIGNMENT
	LDY	#3		;OTHERWISE WE NEED TO GET A NEW PTR
	LDA	(SUBSVAR1),Y
	PHA
	INY
	LDA	(SUBSVAR1),Y
	STA	SUBSVAR2
	PLA
	STA	SUBSVAR1	;USE FIRST FRAME OF ANIMATION AS INFO PTR
	JMP	PU30

PU25:	LDA	#1		;NOT IN USE OR UNKNOWN TYPE.
	RTS

;WE ARE DOING A SPRITE BLOCK THAT NEEDS TO BE MOVED. SUBSVAR3 AND 4 HAVE
;THE X AND Y LOCATIONS.  GET WIDTH AND HEIGHT OF THIS BLOCK.

PU30: 	LDA	SUBSVAR4	;GET SPRITE LOCATION
	CLC
	ADC	SPYADJ		;ADJUST Y ACCORDING TO USER REQUEST
;IFDEF( `TOPBAR', ADC	#TOPADJ , )
.ifdef  TOPBAR
	ADC	#TOPADJ
.endif
	STA	SUBSVAR4	;AND PUT BACK FOR OUR USE

	LDY	#0
	LDA	(SUBSVAR1),Y	;GET FLAG OF 1 OR 2 HIGH SPRITES
	PHA			;SAVE IT
	INY
	LDA	(SUBSVAR1),Y	;GET WIDTH
	PHA
	INY
	LDA	(SUBSVAR1),Y	;GET HEIGHT
	STA	SUBSVAR2
	PLA
	STA	SUBSVAR1	;SAVE BOTH

 	LDY	ANIM_RAM+BS,X	;GET BASE SPRITE INDEX
	LDA	#8		;ASSUME 1 HIGH
	STA	MATH1
	PLA			;GET FLAG OF 1 OR 2 HIGH
	BPL	PU45
	LDA	#16
	STA	MATH1		;IF 2 HIGH, USE 16 AS CORRECTION.	

;MOVE EACH SPRITE IN RELATIONSHIP TO THE REQUESTED LOCATIONS WITHOUT
;ALLOWING OVERFLOW PAST PAGE END.  THERE IS SPECIAL EXCEPTION CODE
;HERE FOR GUN SCANNING.

PU45:

;IFDEF( `GUNLOGIC', `
.ifdef  GUNLOGIC
	LDA	SPRITES_HIDDEN	;IF GUN, SEE IF SCANNING
	BEQ	PU50
	JSR	GUN_PU50	;IF SO, DIFFERENT LOOP TO USE SAVE_SPRITES
	JMP	PU77
.endif

PU50: 	LDA	SUBSVAR1	;GET WIDTH
	STA	MATH2		;SAVE HERE FOR LOOP COUNT
	LDA	SUBSVAR3
	PHA			;SAVE STARTING X LOCATION FOR LOOP
	
PU55: 	LDA	SUBSVAR4	;GET Y LOCATION
	STA	SPRAM,Y		;SET CURRENT Y LOC
	LDA	SUBSVAR3
	STA	SPRAM+3,Y	;AND SET X TOO

	CLC
	ADC	#8		;MOVE RIGHT 8
	BCC	PU60
	LDA	#$FF		;WENT PAST END, FIX IT.
PU60:	STA	SUBSVAR3  	;PUT BACK CORRECTED X
	INY
	INY	
	INY
	INY
	DEC	MATH2		;COUNT 1 LESS ON THIS ROW
	BNE	PU55		;DO ALL OF THEM
	PLA
	STA	SUBSVAR3	;RESTORE START OF ROW X
	LDA	SUBSVAR4	;GET Y LOCATION
	CLC
	ADC	MATH1		;CORRECT Y FOR NEXT ROW ACCORDING TO HEIGHT
	BCS	PU70
	CMP	#$F9
	BCC	PU75
PU70:	LDA	#$F8		;BOTTOM IS F8
PU75:	STA	SUBSVAR4
	DEC	SUBSVAR2	;COUNT 1 LESS ROW
	BNE	PU50

;NOW SEE IF A SPRITE ANIMATION IS SELECTING FRAME BY POSITION.

PU77:	LDA	ANIM_RAM+FB,X	;GET BACK THE FLAG
	AND	#$70		;KEEP FROZEN AND ALIGNMENT BITS
	BEQ	PU90 		;IF NONE, NO NEED TO WORRY
	CMP	#$40		;BUT FROZEN?
	BCS	PU90		;IF SO, DONT UPDATE BY ANY METHOD BUT SELFRAME

;WE ARE UPDATING BY POSITION.  GET THE POSITION WE ARE USING.

	LDA	ANIM_RAM+FB,X
	AND	#3
	CMP	#1		;MAKE SURE NO ERROR (SPRITE BLOCK DOESN'T MOVE)
	BEQ	PU90
		
	LDA	ANIM_RAM+FB,X	;GET BACK X ALIGN BIT (20H)
	ROL	A
	ROL	A
	ROL	A		;GET X BIT INTO CY

	LDY	ANIM_RAM+BS,X
	LDA	CURY
	STA	SUBSVAR3

;IFDEF( `GUNLOGIC', `
.ifdef  GUNLOGIC
	BCS	PU79
	LDA	SPRITES_HIDDEN	;IF GUN, SEE IF SCANNING
	BEQ	PU78
     	TYA
	LSR	A
	LSR	A		;MAKE *1 INDEX IF SCANNING
	TAY
	LDA	SAVE_SPRITES,Y	;AND GET IT HERE
	LDY	ANIM_RAM+BS,X
	JMP	PU80
.endif

PU78:	LDA	SPRAM,Y		;ASSUME UPDATE BY Y
	BCC	PU80
PU79:	LDA	CURX
	STA	SUBSVAR3
	LDA	SPRAM+3,Y	;IF BY X, GET X

PU80: 	CLC
	ADC	SUBSVAR3
	STA	SUBSVAR3	;SAVE THE LOCATION TO USE
	LDA	ANIM_RAM+AF,X	;GET SHIFT COUNT
	AND	#$7
	TAY
	INY
PU82:	DEY
	BEQ	PU83
	LSR	SUBSVAR3	;SHIFT LOCATION DOWN BY REQUESTED AMOUNT
	JMP	PU82

PU83:  	STX	SUBSVAR4	;SAVE INDEX
	LDX	SUBSVAR3	;GET FRAME TO USE
	LDY	#0
	LDA	SUBSVAR5	;GET NUMBER OF FRAMES
	JSR	DIVIDE		;QUICKER TO DIVIDE THAN SUBTRACT ON AVERAGE

;Y NOW HAS FRAME TO USE.  BUT IF THE SPRITE HAS BEEN MIRRORED WE NEED
;TO SELECT BACKWARDS OR ELSE SOMEONE'S IMAGE WILL WALK BACKWARDS!

  	LDX	SUBSVAR4	;GET BACK INDEX
	LDA	ANIM_RAM+AF,X	;SEE IF MIRRORED SPRITE
	AND	#$40
	BEQ	PU85
	LDA	SUBSVAR5	;GET BACK NUMBER OF FRAMES IF SO
	STY	SUBSVAR5
	CLC
	SBC	SUBSVAR5	;MAKE BACKWARDS SELECTION IF MIRRORED
	TAY		

PU85:  	TYA			;GET REMAINDER AS FRAME TO USE
	LDY	ANIM_RAM+FR,X	;GET CURRENT FRAME
	STA	ANIM_RAM+FR,X	;SET CURRENT FRAME
	TYA
	EOR	ANIM_RAM+FR,X	;SEE IF FRAME HAS CHANGED
	BEQ	PU90		;IF NO CHANGE, DON'T WASTE TIME UPDATING.
	JSR	SPFRAME

PU90:	LDA	#0		;SIGNAL SUCCESS
	RTS			

;OBJECT PLACEMENT.  WE JUST UPDATE X AND Y AND SET THE REFRESH NEEDED
;FLAG BIT.  

PU100:	LDA	SUBSVAR3
	AND	#$3F		;KEEP IT IN RANGE
	LSR	A
	LSR	A		;DIVIDE BY 4
	STA	SUBSVAR3	;PUT X HERE

	LDA	SUBSVAR4
	AND	#$FC		;KILL LOW BITS
	CMP	#30
	BCC	PU110
	LDA	#29
PU110: 	ASL	A
	ASL	A
	ORA	SUBSVAR3
	STA	ANIM_RAM+BS,X	;PUT THE X AND Y LOCATION IN

	LDA	ANIM_RAM+NS,X	;GET PLACE WHERE WE KEEP THE REFRESH FLAG	
	ORA	#$80		;SET REFRESH NEEDED 
	STA	ANIM_RAM+NS,X	
	LDA	#0		;AND DONE
	RTS		

;THIS ROUTINE WILL RETURN THE COORDINATES OF THE ANIMATION SLOT SPECIFIED
;IN A.  THEY ARE RETURNED IN X AND Y AND REPRESENT THE SAME VALUES USED
;WITH THE PUTSPRT CALL.  ON RETURN, IF A=0 AND Z THEN X AND Y ARE VALID,
;OTHERWISE A WAS INVALID ON ENTRY.

;JUST TO BE NICE, THIS ROUTINE SAVES THE CORRECTED INDEX INTO SUBSVAR5.
;IT DOES NOT CHANGE ANY OTHER SUBSVARS

GETSPRT:
	JSR	ANIMINDX
	STX	SUBSVAR5
	BEQ	GS10
	RTS
GS10:	LDA	ANIM_RAM+FB,X	;SEE IF OBJECT
	AND	#$3		;REMOVE SPECIAL BITS

;ITS AN OBJECT ANIMATION.  THEY INTERNALLY STORE X AND Y.

	CMP	#3		;SEE IF OBJECT
	BCC	GS40

	LDA	ANIM_RAM+BS,X	;GET X LOCATION
	AND	#$F		;KEEP ONLY THE X PORTION
	ASL	A
	ASL	A		;FIX TO TEXT OFFSET
	TAX
	LDA	ANIM_RAM+BS,X	;GET Y LOCATION
	AND	#$F0		;KEEP ONLY Y COMPONENT
	LSR	A
	LSR	A		;MAKE IT INTO *4
	LDA	#0
	RTS

;ITS A SPRITE OR SPRITE ANIMATION.  THE SPRITE HAS THE LOCATION.

GS40:	LDY	ANIM_RAM+BS,X	;GET INDEX TO SPRITE
	LDX	SPRAM+3,Y  	;GET THE COL ITS ON

;IFDEF( `GUNLOGIC', `
.ifdef  GUNLOGIC
	LDA	SPRITES_HIDDEN	;IF GUN, SEE IF SCANNING
	BEQ	GS45
     	TYA
	LSR	A
	LSR	A
	TAY
	LDA	SAVE_SPRITES,Y	;IF SCANNING GUN, Y IS HERE
	JMP	GS47
.endif

GS45:	LDA	SPRAM,Y		;GET THE ROW
GS47: 	SEC
	SBC	SPYADJ		;ADJUST Y ACCORDING TO USER REQUEST
;IFDEF( `TOPBAR', SBC	#TOPADJ , )
.ifdef TOPBAR
	SBC	#TOPADJ
.endif
	TAY
	LDA	#0
	RTS

;THIS ROUTINE WILL MOVE A SPRITE BLOCK RELATIVE TO THE CURRENT LOCATION.
;ON ENTRY, A CONTAINS THE SLOT NUMBER, X HAS THE SIGNED COLUMN CHANGE
;(+127 TO -128) AND Y HAS THE SIGNED ROW CHANGE.   THE SPRITES WILL NOT
;BE ALLOWED TO WRAP FROM ONE SIDE OF THE SCREEN TO THE OTHER.

;THIS ROUTINE ALSO SUPPORTS THE SOLID BACKGROUND OPTION.  IF THE
;THING BEING MOVED IS A SPRITE BLOCK AND IT IS PLACED OVER SOLID DATA,
;THE REQUEST MOVE WILL BE REJECTED. 

;THE ANIMATION ALIGNMENT IS ALSO SUPPORTED BY THIS CALL BUT ACTUALLY
;THIS HAPPENS IN PUTSPRT.

;ON RETURN, A HAS A FLAG
;0=SUCCESS.  RESULTX AND RESULTY RETURN THE RESULTING X AND Y POSITIONS IF
;	     THE MOVE WAS FOR A SPRITE OR SPRITE ANIMATION.  LOSTX AND LOST
;	     Y ARE NON-ZERO IF THE SPRITE MOVED IN THE CORRESPONDING DIRECTION
;	     AND EITHER WOULD HAVE (GOING LEFT OR UP) OR DID MOVE OFF THE
;	     VIEWABLE SCREEN).  THEY ARE TRUE EVEN FOR PARTIAL MOVES OFF.
;	     THEY HAVE THE AMOUNT IT MOVED OFF (SIGNED VALUE).
;
;1=UNUSED SLOT
;-1=BAD SLOT #
;4=MOVE REJECTED, OVER SOLID BACKGROUND.  SOLIDCHAR RETURNS FIRST SOLID HIT.

MOVESPRT:
	STX	SUBSVAR1
	STY	SUBSVAR2	;SAVE THE CORRECTIONS
	STA	SUBSVAR3	;SAVE THE SLOT
	JSR	GETSPRT		;GET CURRENT SPRITE LOCATION
	BEQ	MS10
MS5:	RTS			;RETURN IF BAD SLOT

MS10: 	STX	MATH1
	STY	MATH2		;SAVE CURRENT LOCS IN CASE OF SOLID FEATURE
	LDX	SUBSVAR5	;GET BACK SLOT INDEX
	LDA	ANIM_RAM+FB,X	;GET FLAG TYPE
	AND	#$3		;MASK OFF SPECIAL BITS
	BEQ	MS5	
	CMP	#3		;SEE IF OBJECT
	BNE	MS12
	JMP	MS40

;SPRITE BLOCK

MS12: 	LDA	#0
	STA	LOSTX		;RESET MOVED OFF SCREEN ON X AXIS FLAG
	LDA	SUBSVAR1	;GET X CORRECTION
	CLC
	BPL	MS15		;IF PLUS, DIFFERENT LOGIC
	ADC	MATH1		;IF MINUS, WE WANT A CARRY
	BCS	MS20
	STA	LOSTX
	LDA	#0		;OTHERWISE STOP AT LEFT
	JMP	MS20

MS15:	ADC	MATH1		;FIX X	
	BCC	MS20
	STA	LOSTX
	LDA	#$FF		;IF PAST END, STOP AT END
MS20:	STA	MATH1		;SAVE DESIRED NEW X LOCATION

	LDA	#0
	STA	LOSTY		;RESET FLAG OF MOVED OFF SCREEN IN Y DIRECTION
	LDA	SUBSVAR2	;GET DESIRED Y CORRECTION
	CLC
	BPL	MS25		;USE POSITIVE LOGIC IF PLUS
	ADC	MATH2
	BCS	MS35
	STA	LOSTY		;SET FLAG OF MOVED OFF VIEWABLE SCREEN
	LDA	#0
	JMP	MS35

MS25:	ADC	MATH2		;FIX Y
	BCS	MS30
	CMP	#$F9
	BCC	MS35
MS30: 	SEC
	SBC	#$F8
	STA	LOSTY
	LDA	#$F8		;IF PAST BOTTOM, STOP AT END
MS35:	STA	MATH2		;SAVE DESIRED NEW Y LOCATION.

;MATH1 AND MATH2 HAVE THE NEW DESIRED X AND Y LOCATIONS, SUBSVAR3 HAS THE 
;SLOT #, SUBSVAR5 HAS THE SLOT INDEX.  

;SEE IF WE ARE TESTING FOR MOVEMENT ONTO SOLID AREAS.  WE TEST THAT BEFORE
;WE MAKE THEIR CHANGE.

	LDA	ANIM_RAM+FB,X
	AND	#8		;SOLID DEFINED?		
	BNE	CS10
	JMP	MS39		;IF NOT, GO DO THE MOVE

;WE HAVE TO CHECK THIS MOVE OUT, IT MAY NOT BE OK.  WE MIGHT BE MOVING
;OVER A SOLID CHARACTER AREA.

CS10:	LDA	MATH1
	PHA
	LDA	MATH2
	PHA
	LDA	SUBSVAR3
	PHA			;SAVE THE VALUES

;FIRST MAKE THE OFFSETS IN THE BACKGROUND.  

	LDA	MATH2		;GET SPRITE'S Y LOCATION
	CLC
	ADC	CURY		;MAKE OFFSET IN BACKGROUND
	STA	MATH3
	LDA	#0
	ADC	CURY+1
	STA	MATH4		;MATH3 & 4 HAVE Y PIXEL LOC IN BACKGROUND

	LDA	MATH1
	CLC
	ADC	CURX		;MAKE OFFSET IN BACKGROUND
	STA	SUBSVAR3	
	LDA	#0
	ADC	CURX+1
	STA	SUBSVAR4	;SUBSVAR3&4 HAVE X PIXEL LOC IN BACKGROUND

	LSR	SUBSVAR4
	ROR	SUBSVAR3
	ROR	SUBSVAR4
	ROR	SUBSVAR3
	ROR	SUBSVAR4
	ROR	SUBSVAR3	;MAKE 3=TEXT COL, 
	ROR	SUBSVAR4	;4=ODD PIXELS

	LSR	MATH4
	ROR	MATH3
	ROR	MATH4
	ROR	MATH3
	ROR	MATH4
	ROR	MATH3	;MAKE 3=TEXT ROW, 
	ROR	MATH4	;4=ODD PIXELS

;NOW MAKE THE WIDTH AND HEIGHT TO CHECK IN THOSE BACKGROUNDS.

	LDA	ANIM_RAM+PTRL,X
	STA	SUBSVAR1
	LDA	ANIM_RAM+PTRH,X
	STA	SUBSVAR2	;MAKE (SUBSVAR1) POINT TO THE ANIMATION/SPRITE

	LDA	ANIM_RAM+FB,X
	AND	#3
	CMP	#1		;JUST A SPRITE?
	BEQ	CS30		;IF IT IS, PTR IS TO A BLOCK WITH WIDTH/HEIGHT
	LDY	#3
	LDA	(SUBSVAR1),Y
	PHA
	INY
	LDA	(SUBSVAR1),Y
	STA	SUBSVAR2
	PLA
	STA	SUBSVAR1	;IF ANIMATION, NEED POINTER TO BLOCK

CS30:	LDY	#1
	LDA	(SUBSVAR1),Y	;GET WIDTH
	STA	MATH1		;SAVE HERE
	INY
	LDA	(SUBSVAR1),Y
	STA	MATH2		;SAVE HEIGHT

	LDA	MATH4		;GET ODD PIXELS ON ROW
	AND	#$60;#B'11100000	;SEE IF NEED EXTRA ROW CHECKED
	BEQ	CS40
	INC	MATH2		;IF IN MIDDLE OF A TEXT ROW, WE EXTEND TO NEXT

CS40:	LDA	SUBSVAR4	;GET ODD PIXELS ON COL
	AND	#$60;#B'11100000
	BEQ	CS50
	INC	MATH1		;IF THERE ARE SOME, NEED EXTRA COL CHECK

CS50:	LDA	MATH1
	STA	SUBSVAR4	;PUT COLS TO CHECK HERE
	LDA	MATH2		;GET ROWS TO CHECK
	STA	MATH4		;SAVE HERE

;NOW MATH4 = ROWS TO CHECK, SUBSVAR4 = COLS TO CHECK.
;MATH3 = ROW WE ARE ON.  SUBSVAR3 = COL WE ARE ON.
;MAKE (SUBSVAR1) POINT TO THE DATA IN THE BACKGROUND.

	LDX	MATH3
	LDY	BACKWIDE
	JSR	MUL
	LDA	SUBSVAR3
	JSR	ADD_WORD		;MAKE POINTER TO DATA BLOCK
	TXA
	CLC
	ADC	BACKBASE
	STA	SUBSVAR1
	TYA
	ADC	BACKBASE+1

;IFDEF( `PAGED', ORA	#$80, )	;IF PAGED BACKGROUND, FIX OFFSET HERE
.ifdef  PAGED
	ORA	#$80
.endif
	STA	SUBSVAR2		;MAKE (SUBSVAR1) POINT TO DATA

;GET VALUE TO CHECK AGAINST

	LDX	SUBSVAR5		;NEED TO RESTORE SLOT INDEX
	LDA	ANIM_RAM+SL,X		;GET USER'S SOLID CHARACTER VALUE
	STA	SUBSVAR5		;SAVE IT HERE.
	
CS100:	LDX	SUBSVAR4		;GET COLS TO CHECK
	LDY	#0			;MAKE INDEX

;IFDEF( `PAGED', `
.ifdef  PAGED
	LDA	BACKBASE+1	;SEE IF IN SECOND PAGE
	BMI	CS110		;IF NOT, USE NORMAL LOOP
	LDA	#4
	STA	TESTIT
	JSR	CALL_CHK  	;IF IN SECOND PAGE, CHECK ROW THERE.
	LDA	#0
	STA	TESTIT
	BCS	CS200
	JMP	CS115
.endif

CS110:	LDA	(SUBSVAR1),Y		;GET A CHAR
	INY
	CMP	SUBSVAR5		;SOLID?
	BCS	CS200			;SKIP IF SO.
	DEX
	BNE	CS110
	
CS115:	LDA	SUBSVAR1
	CLC
	ADC	BACKWIDE		;SKIP TO NEXT ROW IF THIS ONE CHECKED
	STA	SUBSVAR1
	BCC	CS120
	INC	SUBSVAR2
CS120:	DEC	MATH4			;COUNT ANOTHER ROW CHECKED
	BNE	CS100

	PLA		
	STA	SUBSVAR3
	PLA	
	STA	MATH2
	PLA
	STA	MATH1		;OK TO DO IT, RESTORE THE VALUES USED.

;OK TO MAKE THE MOVE.  GET THE PARTICULARS FROM MATH1, MATH2, AND SUBSVAR3.

MS39:	LDX	MATH1
	STX	RESULTX
	LDY	MATH2
	STY	RESULTY		;SET THESE FOR CALLER
	LDA	SUBSVAR3	;GET BACK SLOT
	JSR	PUTSPRT
	RTS

;NOT OK TO MOVE, ITS SOLID.  A HAS THE CHAR VALUE

CS200: 	STA	SOLIDCHAR	;SAVE FOR CALLER
	PLA
	PLA
	PLA
	LDA	#4
	RTS

;OBJECT ANIMATION.  MUST STOP AT DIFFERENT X AND Y LOCATIONS.

MS40:	LDA	MATH1
	CLC
	ADC	SUBSVAR2	;FIX X	
	BCS	MS45
	CMP	#64
	BCC	MS47
MS45:	LDA	#63		;IF PAST END, STOP AT END
MS47:	TAX			;PUT WHERE PUTSPRT WANTS IT

	LDA	MATH2		;GET Y
	CLC
	ADC	SUBSVAR1	;FIX Y
	BCS	MS50
	CMP	#$30
	BCC	MS55
MS50:	LDA	#$29		;IF PAST BOTTOM, STOP AT END
MS55:	TAY			;SET UP FOR PUTSPRT
	LDA	SUBSVAR3	;GET BACK SLOT
	JSR	PUTSPRT
	LDA	#0
	RTS

;THIS ROUTINE IS USED AT BOOT TO ZERO THE SPRITE CONTROL RAM.  KILLSPRT
;CANNOT BE USED BECAUSE THE DATA WILL BE INTERPRETED AND IT IS INVALID AT
;THAT TIME.

ZERO_ANIM:
 	LDA	#0
	TAX
ZA10:	STA	ANIM_RAM,X
	INX
	CPX	#SPMEM		;SEE IF DONE
	BNE	ZA10
	RTS

;THIS ROUTINE WILL KILL (FREE UP) THE ANIMATION SLOT SPECIFIED IN A.
;A VALUE OF -1 MAY BE USED TO FREE UP ALL SLOTS. IT IS OK TO FREE UP 
;A SLOT THAT IS ALREADY FREE.   THIS ROUTINE SETS THE SPRITE RAM FOR
;THE ENTRY (IF IT WAS A SPRITE) TO ALL OFF SCREEN VALUES SO THAT
;INITSPRT DOES NOT HAVE TO DO THAT.

;ON RETURN, IF Z OR A=0 THEN SUCCESS.  IF A=-1 OR NZ THEN  THE SLOT 
;NUMBER YOU PASSED WAS INVALID (TOO HIGH).

KILLSPRT:
	CMP	#-1		;FREE ALL?
	BNE	KS10

;NEED TO FREE THEM ALL.  CALL OURSELVES UNTIL INVALID INDEX RETURNED.

KILLALL:		;THIS IS AN ALLOWED USER ENTRY POINT.

	LDA	#0
KS5:	PHA
	JSR	KILLSPRT
	BNE	KS7
	PLA
	CLC
	ADC	#1		;JUST KEEP GOING USING THIS ROUTINE.
	JMP	KS5
KS7:	PLA
	LDA	#0
	RTS

;NOT KILL ALL.  CHECK THE INDEX.

KS10:	JSR	ANIMINDX
	BNE	KS50

;ITS A VALID SLOT.  IF SPRITE BLOCK WE MUST HIDE THE SPRITES TOO.
;ITS ALSO OK TO JUMP HERE WITH A VALID SLOT INDEX IN X IF YOU WANT TO 
;KILL WITHOUT THE CALL.  USED BY AUTOKILL FROM CHECK_ANIM.  X IS PRESERVED.

MANUAL_KILL:
	LDA	ANIM_RAM+FB,X	;GET FLAG BYTE
	AND	#$3
	BEQ	KS40		;IF DONE, END
	CMP	#3		;OBJECT?
	BEQ	KS40

;ITS A SPRITE BLOCK. WE MUST MOVE THEM OFF SCREEN.

	TXA
	PHA			;SAVE INDEX
	LDA	ANIM_RAM+BS,X	;GET BASE SPRITE INDEX
	TAY
	LDA	ANIM_RAM+NS,X	;GET NUMBER TO HIDE
	TAX
	JSR	HIDE2		;USE THIS ROUTINE TO DO IT.
	PLA
	TAX

;DONE.  FREE THE SLOT.

KS40:	LDA	#0
	STA	ANIM_RAM+FB,X	;FREE IT UP LAST OF ALL
KS50:	RTS


;THIS ROUTINE WILL MOVE A BLOCK OF SPRITES OR A SPRITE ANIMATION BEHIND
;OR IN FRONT OF THE BACKGROUND.  LOAD A WITH THE SLOT NUMBER AND
;X WITH 20H TO MOVE BEHIND AND 00 TO MOVE IN FRONT.  A RETURNS Z IF
;SUCCESS, OTHERWISE A=-1 AND INVALID SLOT NUMBER (Z FLAG SET ACCORDINGLY).

;THIS ROUTINE ACTUALLY RESETS BIT 20H IN THE SPRITE PALLETTE BYTE AND
;THEN XORS THE VALUE YOU PASS IN X TO THE SPRITE'S PALETTE INFO.  YOU
;CAN USE THIS FACT TO CHANGE PALETTES WITH A CALL IF YOU HAVE A SIMPLE
;SPRITE AND KNOW WHAT THE OLD VALUES WERE. FOR ANIMATIONS THIS WOULD
;NOT WORK SINCE THE PAL DATA IS RELOADED WITH EACH ANIMATION (BUT
;THE BACK/FRONT BIT IS PRESERVED).

;NZ AND A=1 IS RETURNED IF STRUCTURE IS NOT A SPRITE STRUCTURE
;OR IS NOT IN USE.  -1 MEANS INVALID SLOT #.

INFRONT:
	STX	SUBSVAR1	;SAVE DESIRED CONDITION
	JSR	ANIMINDX
	BNE	IF4		;END IF BAD SLOT #

	LDA	ANIM_RAM+FB,X	;GET TYPE OF STRUCTURE
	AND	#$3
	CMP	#1		;IF SIMPLE ANIMATION, WE ARE OK NOW
	BEQ	IF20
     	CMP	#2
	BEQ	IF20
	LDA	#1
IF4:	RTS


IF20:	LDY	ANIM_RAM+BS,X	;GET BASE SPRITE #
	LDA	ANIM_RAM+NS,X
	TAX			;AND COUNT

IF30:	LDA	SPRAM+2,Y	;GET THE BEHIND/IN USE BITS
	AND	#$DF		;REMOVE THE BEHIND BIT
	EOR	SUBSVAR1	;PUT BACK IN IF DESIRED BY USER
	STA	SPRAM+2,Y	;SAVE BACK OUT
	INY
	INY
	INY
	INY			;SKIP TO NEXT SPRITE
	DEX
	BNE	IF30
	LDA	#0		;SUCCESS
	RTS

;THIS ROUTINE WILL CHECK TO SEE IF AN ANIMATION OR SPRITE HAS COLLIDED
;(IS ON TOP OF) ANOTHER ANIMATION OR SPRITE.  LOAD A WITH THE SLOT NUMBER
;OF THE ANIMATION OR SPRITE TO BE CHECKED AGAINST THE OTHERS.
;NOTE THAT IF THERE ARE MULTIPLE COLLISIONS THIS ROUTINE WILL NOT DETECT
;FURTHER ONES.  CALL NEXT_COLLISION TO CONTINUE THE SEARCH.

;DO NOT CALL THIS ROUTINE FROM DIFFERENT LEVELS.  CHOOSE NMI OR NON-NMI
;EXCLUSIVELY BUT NOT BOTH!

;A RETURNS A FLAG:
;0 (AND Z) = SUCCESS AND X HAS SLOT # OF COLLIDING ANIMATION OR SPRITE 
;	     (-1 IN X MEANS NONE).
;-1 = INVALID SLOT #
;1 = UNUSED SLOT # OR OUR SLOT IS NOT POSITIONED YET.

COLLISION:

 	LDX	#0
	STX	COLLINDX	;START BY ZEROING THE INDEX TO CHECK FROM

;THIS ENTRY POINT IS SHARED BY UP_COLLISION WHO LOADS COLLINDX WITH A
;VALUE OTHER THAN 0.

C5:	JSR	USEDINDX	;CHECK FOR ERRORS -1 AND 1 IN REG A.
	BPL	C10
    	LDA	#1		;RETURN ERR 1 IF NOT POSITIONED YET.
	RTS

;HAVE THE SLOT INDEX OF US.  SAVE IT FOR COMPARE SO WE WILL SKIP OUR OWN
;AND THEN GET OUR LOCATION RANGES.

C10:	JSR	ANIMRANGE	;GET THE PARAMETERS TO CHECK AGAINST
	STX	OURINDX		;SAVE OUR INDEX

	LDA	SUBSVAR1
	STA	COLL1		
	LDA	SUBSVAR2
	STA	COLL2		
	LDA	SUBSVAR3
	STA	COLL3		
	LDA	SUBSVAR4
	STA	COLL4		;NEED TO MORE HERE FOR LOOP		

;CHECK EACH SLOT TO SEE IF WE ARE ON TOP.  

C20:	LDX	COLLINDX   	;GET THE INDEX WE ARE CHECKING
	TXA			;GET CURRENT INDEX TO CHECK
	EOR	OURINDX		;SEE IF SAME AS OURS
	BEQ	C100		;SKIP IT, NO COLLISION WITH OURSELVES!
	
	JSR	ANIMRANGE	;IF OK INDEX, GET THE RANGE
	BNE	C100		;SKIP IF NOT IN USE OR NOT POSITIONED

;SEE IF OUR LOW X IS INBETWEEN THIS ONE OR IF OUR HIGH X IS.  

	LDA	COLL1
	CMP	SUBSVAR1
	BCS	C25

;THE LOW WAS BELOW THIS WHOLE THING.  THERE IS STILL A CHANCE IF OUR HIGH
;IS ABOVE THE LOW.

	LDA	COLL2
	CMP	SUBSVAR1
	BCS	C50
	JMP	C100

;CONTINUE THE INBETWEEN CHECK

C25:	LDA	SUBSVAR2
	CMP	COLL1
	BCS	C50	

C30:	LDA	COLL2
	CMP	SUBSVAR1
	BCC	C100
	LDA	SUBSVAR2
	CMP	COLL2
	BCC	C100

;THE X IS IN RANGE.  SEE IF THE Y IS.			

C50:	LDA	COLL3
	CMP	SUBSVAR3
	BCS	C55

;THE LOW WAS BELOW THIS WHOLE THING.  THERE IS STILL A CHANCE IF OUR HIGH
;IS ABOVE IT.

	LDA	COLL4
	CMP	SUBSVAR3
	BCS	C80
	JMP	C100

;CONTINUE THE INBETWEEN CHECK

C55:	LDA	SUBSVAR4
	CMP	COLL3
	BCS	C80	

C60:	LDA	COLL4
	CMP	SUBSVAR3
	BCC	C100
	LDA	SUBSVAR4
	CMP	COLL3
	BCC	C100

;WE HAVE A COLLISION.

C80:	LDY	#0
	LDA	#ANIM_WIDE
	JSR	DIVIDE		;MAKE SLOT #
	JMP	C110

;WE DON'T HAVE A COLLISION.  GO TO NEXT.
;THIS ENTRY POINT ALSO CALLED BY NEXT_COLLISION.

C100:	TXA
	CLC
	ADC	#ANIM_WIDE		;GO TO NEXT INDEX
	TAX
	STA	COLLINDX		;SET INDEX FOR NEXT LOOP
	CMP	#ANIM_WIDE*SPSLOTS	;DONE INDEXING?
	BCC	C20			;IF NOT, TRY AGAIN.
	LDX	#-1			;RETURN NOT FOUND IF NONE	
	LDA	#0
	STA	COLLINDX		;AND FOR SAFETY, RESET CONTINUE INDX.

;X HAS THE VALUE OF -1 IF NONE FOUND.

C110:	LDA	#0
	RTS

;THIS ROUTINE WILL CONTINUE A COLLISION CHECK STARTED WITH COLLISION.
;WHEN A COLLISION IS FOUND, AN INDEX IS SAVED TO POINT TO THE SPRITE
;SLOT FOLLOWING THAT COLLISION.  YOU CAN IGNORE THAT COLLISION AND
;CONTINUE BY CALLING THIS ROUTINE.  BE SURE YOU DON'T CALL IF COLLISION
;RETURNS -1 (NO COLLISIONS) OR IF COLLISION HAS NOT BEEN CALLED FIRST
;TO SET THINGS UP.  ALSO DON'T CALL HERE IF COLLISION RETURNS AN ERROR.
;YOU SHOULD ONLY CALL HERE IF COLLISION HAS JUST RETURNED A VALID COLLISION
;SINCE THE LAST TIME IT WAS CALLED.  MAKE SURE NO OTHER PIECE OF YOUR
;CODE CALLS IT BETWEEN THE LAST CALL WITH SOME OTHER SLOT TO CHECK FOR.

NEXT_COLLISION:
	LDX	COLLINDX
	JMP	C100		;GO SHARE CODE TO CHECK FOR NEXT	

;THIS ROUTINE FUNCTIONS EXACTLY THE SAME AS COLLISION EXCEPT THAT YOU
;MAY GIVE IT A SLOT NUMBER TO START THE COLLISION CHECK FROM IN X.  IT
;WILL NOT CHECK FOR COLLISIONS WITH SLOTS BELOW THAT SLOT #.  

;ON ENTRY, A HAS THE SLOT NUMBER OF THE ANIMATION OR SPRITE TO BE CHECKED
;AGAINST THE OTHERS (JUST AS WITH A CALL TO COLLISION).  X HAS THE SLOT
;NUMBER FROM WHICH TO START THE CHECK.  THE RETURN VALUES ARE THE SAME AND
;YOU MAY CONTINUE THE CALL WITH NEXT_COLLISION EXACTLY THE SAME AS IF
;COLLISION WERE CALLED.

UPPER_COLLISION:
	STA	OURINDX		;TEMPORARILY SAVE SLOT #
	TXA			;GET SLOT NUMBER TO CHECK FROM
	JSR	ANIMINDX	;SEE IF OK
	BEQ	UCL10
	RTS			;RETURN -1 IF INVALID X

UCL10:	STX	COLLINDX	;SAVE INDEX TO CHECK FROM
	LDA	OURINDX		;GET BACK OUR SLOT #
	JMP	C5		;AND GO SHARE CODE WITH COLLISION

;THIS ROUTINE WILL TAKE A SPRITE SLOT # IN A AND A PALETTE COLOR (0-3)
;IN X AND WILL UPDATE THE SPRITE BLOCK.

;A RETURNS A FLAG:
;0 (AND Z) = SUCCESS 
;-1 = INVALID SLOT # OR NOT SPRITE BLOCK.
;1 = UNUSED SLOT # 

CHANGEPAL:
	STX	SUBSVAR1
	JSR	USEDINDX	;CHECK FOR UNUSED OR INVALID
	AND	#$03		;IT RETURNS THE FLAG BYTE
	CMP	#3
	BNE	CPL20
	LDA	#-1
	RTS

CPL20:	LDA	ANIM_RAM+BS,X	
	TAY			;POINT TO THE SPRITE BLOCK
	LDA	ANIM_RAM+NS,X	;GET NUMBER OF SPRITES
	TAX			;SET FOR LOOP
	LDA	SUBSVAR1
	AND	#3		;GET PALETTE BITS
	STA	SUBSVAR1
	
CPL30:	LDA	SPRAM+2,Y	;GET THE SPRITE PALETTE BYTE
	AND	#$FC		;REMOVE PALETTE INFO
	ORA	SUBSVAR1
	STA	SPRAM+2,Y	;SET IN NEW PALETTE INFO
	INY
	INY
	INY
	INY	
	DEX
	BNE	CPL30
	LDA	#0
	RTS

;THIS ROUTINE WILL TAKE A SPRITE SLOT # IN A AND A SPRITE DEFFINITION
;POINTER IN Y:X AND SWAP THAT DEFFINITION POINTER INTO THAT ACTIVE SPRITE
;SLOT WITHOUT CHANGING ANY OTHER VALUES.  THE NEW ANIMATION WILL NOT
;UPDATE UNTIL A NEW FRAME IS SELECTED.  THE NEW DEFFINITION MAY ONLY
;DIFFER IN PALETTE OR CHARACTER VALUES.

;A RETURNS A FLAG:
;0 (AND Z) = SUCCESS 
;-1 = INVALID SLOT # OR NOT SPRITE BLOCK.
;1 = UNUSED SLOT # 

SWAPSPRT:

	STX	SUBSVAR1
	STY	SUBSVAR2

	JSR	USEDINDX	;MAKE SURE ITS USED

  	LDA	SUBSVAR1
	STA	ANIM_RAM+PTRL,X
	LDA	SUBSVAR2       	;GET BACK INDEXES
	STA	ANIM_RAM+PTRH,X	;PUT MEMORY LOCATION INTO STRUCTURE
	JSR	SPFRAME		;USE SUBSVAR1 POINTER TO UPDATE SLOT IN X.
	LDA	#0
	RTS

;THIS SUB WILL SET THE FLASH VARIABLE IN THE SPRITE DEFFINITION THUS CAUSING
;SPRITE TO FLASH.  A SHOULD HAVE THE SPRITE SLOT # AND X SHOULD HAVE
;THE FLASH DURATION IN 1/60 TICKS.

;A RETURNS A FLAG:
;0 (AND Z) = SUCCESS 
;-1 = INVALID SLOT # OR NOT SPRITE BLOCK.
;1 = UNUSED SLOT # 

FLASH:
	STX	SUBSVAR1
	JSR	USEDINDX	;CHECK FOR UNUSED OR INVALID
	AND	#$03		;IT RETURNS THE FLAG BYTE
	CMP	#3
	BNE	FLS20
	LDA	#-1
	RTS

FLS20:	LDA	SUBSVAR1
	STA	ANIM_RAM+ABL,X	
	LDA	#0
	RTS	

;THIS SUB IS USED BY COLLISION DETECTION LOGIC.  GIVEN AN INDEX IN X IT WILL 
;RETURN THE 4 CORNERS OF THAT BLOCK.  SUBSVAR1=LOW X, SUBSVAR2=HIGH X,
;SUBSVAR3=LOW Y, SUBSVAR4=HIGH Y.  ON RETURN, IF A=0 AND Z THEN SUCCESS.
;IF A<>0 THEN THE INDEX WAS NOT POSITIONED YET OR WAS NOT IN USE.  DO
;NOT PASS AN INVALID INDEX.  THIS IS NOT SLOT # ORIENTED, X HAS AN INDEX.
;A SPECIAL CASE IS ALSO SUPPORTED BY THIS ROUTINE.  IF AN OBJECT ANIMATION
;IS NOT WITHIN THE CURRENT VIDEO PAGE THEN NZ IS RETURNED SINCE THERE
;CAN BE NO COLLISIONS WITH SPRITES WHICH CAN ONLY BE IN THE CURRENT PAGE.

;THE VALUES RETURNED ARE PIXEL LOCATIONS, NOT TEXT CELL LOCATIONS.  OBJECT
;ANIMATIONS ARE CORRECTED INTO PIXEL LOCATIONS.

ANIMRANGE:
	LDA	ANIM_RAM+PTRL,X
	STA	SUBSVAR1
	LDA	ANIM_RAM+PTRH,X
	STA	SUBSVAR2	;MAKE POINTER TO STRUCTURE

	LDA	ANIM_RAM+FB,X	;GET FLAG BYTE
	BEQ	AR100
	BMI	AR100		;IF NOT IN USE OR IF NOT POSITIONED, RETURN NZ
	AND	#3		;GET ONLY ID BITS
	CMP	#3		;OBJECT?
	BEQ	AR70

;SPRITE BLOCK OR ANIMATION.  GET ITS WIDTH AND HEIGHT

	CMP	#1
	BEQ	AR30		;IF JUST SPRITE, OUR PTR IS GOOD
	LDY	#3		;OTHERWISE WE NEED TO GET A NEW PTR
	LDA	(SUBSVAR1),Y
	PHA
	INY
	LDA	(SUBSVAR1),Y
	STA	SUBSVAR2
	PLA
	STA	SUBSVAR1	;USE FIRST FRAME OF ANIMATION AS INFO PTR

AR30:	LDY	#2
	LDA	(SUBSVAR1),Y	;GET HEIGHT
	ASL	A
	ASL	A
	ASL	A		;MAKE *8 HEIGHT FOR PIXEL HEIGHT
	STA	SUBSVAR4	;SAVE HERE
	DEY
	LDA	(SUBSVAR1),Y	;GET WIDTH
	ASL	A
	ASL	A
	ASL	A		;MAKE PIXEL WIDTH
	STA	SUBSVAR3	;SAVE HERE
	DEY
	LDA	(SUBSVAR1),Y	;GET FLAG OF HEIGHT
	BPL	AR40
	ASL	SUBSVAR4	;DOUBLE HEIGHT IF DOUBLE HIGH

AR40:	LDY	ANIM_RAM+BS,X	;GET INDEX TO SPRITE
	LDA	SPRAM+3,Y  	;GET THE COL ITS ON
	STA	SUBSVAR1	;SAVE COL
	CLC
	ADC	SUBSVAR3	;MAKE ENDING COL
	STA	SUBSVAR2
	DEC	SUBSVAR2	;AND NEED TO BACK UP TO BE ON IT	

;IFDEF( `GUNLOGIC', `
.ifdef  GUNLOGIC
	LDA	SPRITES_HIDDEN	;IF GUN, SEE IF SCANNING
	BEQ	AR50
     	TYA
	LSR	A
	LSR	A
	TAY
	LDA	SAVE_SPRITES,Y	;IF GUN SCANNING, Y IS STORED HERE
	LDY	ANIM_RAM+BS,X	;GET BACK Y INDEX
	JMP	AR55
.endif

AR50:	LDA	SPRAM,Y		;GET ROW ITS ON
AR55:	STA	SUBSVAR3	;SAVE HERE
	CLC
	ADC	SUBSVAR4
	STA	SUBSVAR4
	DEC	SUBSVAR4	;MAKE ENDING PIXEL ROW
	LDA	#0
	RTS

AR100:	LDA	#-1		;ERROR  RETURN CODE IF UNUSED OR NOT POS.
	RTS

;OBJECT ANIMATION.  WE NEED TO CONVERT THE TEXT CELL LOCATIONS INTO
;PIXEL OFFSETS AND WE NEED TO MAKE SURE ITS IN THE CURRENT PAGE.

AR70: 	LDY	#3
	LDA	(SUBSVAR1),Y	;GET LOW OFFSET OF FIRST BLOCK
	STA	SUBSVAR3
	INY
	LDA	(SUBSVAR1),Y	;GET HIGH
	STA	SUBSVAR2
	LDA	SUBSVAR3
	STA	SUBSVAR1	;MAKE (SUBSVAR1) POINT TO THE OBJECT FLAGS

	LDY	#2
	LDA	(SUBSVAR1),Y	;GET HEIGHT IN CELLS
	STA	SUBSVAR4	;SAVE HERE
	DEY
	LDA	(SUBSVAR1),Y	;GET WIDTH
	STA	SUBSVAR2	;SAVE HERE

	LDA	ANIM_RAM+BS,X	;GET ROW AND COLUMN BYTE
	AND	#$F0
	ASL	A		;ITS /4.  MAKE IT *8
	STA	SUBSVAR3	;SAVE STARTING PIXEL ROW
	LDA	SUBSVAR4	;GET BACK HEIGHT IN CELLS
	ASL	A
	ASL	A
	ASL	A		;MAKE PIXEL HEIGHT
	CLC
	ADC	SUBSVAR3	
	STA	SUBSVAR4	;MAKE ENDING ROW
	DEC	SUBSVAR4

	LDA	ANIM_RAM+BS,X	;GET ROW AND COLUMN BYTE
	AND	#$F		;KEEP ONLY COLUMN
	ASL	A
	ASL	A	
	ASL	A
	ASL	A
	ASL	A		;MAKE PIXEL STARTING COLUMN, DISCARD PAGE
	STA	SUBSVAR1	;SAVE STARTING PIXEL COL
	LDA	SUBSVAR2	;GET BACK WIDTH IN CELLS
	ASL	A
	ASL	A
	ASL	A		;MAKE PIXEL WIDTH
	CLC
	ADC	SUBSVAR1	
	STA	SUBSVAR2	;MAKE ENDING PIXEL COL
	DEC	SUBSVAR2

;WE HAVE THE VALUES BUT MAKE SURE ITS IN THE CURRENT PAGE

	LDA	ANIM_RAM+BS,X	;GET BACK CURRENT PAGE LOCATION
	LSR	A
	LSR	A
	LSR	A		;MOVE PAGE BIT INTO REG2000 POSITION
	EOR	REG2000
	AND	#1		;MAKE SURE THEY ARE EQUAL
	BNE	AR100
	LDA	#0		;RETURN SUCCESS FLAG
	RTS

;THIS CALL WILL ACTIVATE THE SCREEN ALIGNMENT CAPABILITY OF THE ANIMATION
;ROUTINES.  WHEN ACTIVE, THE ANIMATION FRAME IS SELECTED AS A RESULT
;OF SCREEN POSITION RATHER THAN TIME.  YOU SPECIFY X OR Y ALIGNMENT
;(WHICH AXIS IS TO BE USED FOR THE ALIGNMENT) AND THE AMOUNT TO SHIFT
;THE SCREEN POSITION RIGHT TO GET THE FRAME #.  RESULTING VALUES OVER
;THE NUMBER OF FRAMES WILL WRAP.

;TO USE, LOAD A WITH THE SLOT #, LOAD Y WITH THE SHIFT RIGHT COUNT (0-7)
;AND LOAD X WITH 20H FOR X ALIGNMENT AND 10H FOR Y ALIGNMENT.
;A RETURNS A FLAG:
;0 (AND Z) = SUCCESS
;-1 = INVALID SLOT #
;1 = UNUSED SLOT #

ALIGNANIM:
	STX	SUBSVAR3
	STY	SUBSVAR4	
	JSR	USEDINDX	;CHECK FOR ERRORS -1 AND 1
	AND	#$CF		;REMOVE ANY OLD ALIGNMENT BITS
	ORA	SUBSVAR3	;SET IN THE NEW ONES
	STA	ANIM_RAM+FB,X
	LDA	SUBSVAR4	;GET ALIGNMENT VALUE
	AND	#$7		;ONLY 3 BITS VALID
	STA	SUBSVAR4
	LDA	ANIM_RAM+AF,X	;GET THE AUXILIARY FLAGS
	AND	#$F8		;REMOVE OLD BITS FOR ALIGNMENT
	ORA	SUBSVAR4
	STA	ANIM_RAM+AF,X	;SET BACK WITH NEW VALUE
	LDA	#0
	RTS

;THIS CALL ACTIVATES THE SOLID BACKGROUND FUNCTION OF THE SPRITE MOVEMENT
;ROUTINE MOVESPRT.  WHEN ACTIVE, ANY POSITION GENERATED AS A RESULT OF
;MOVESPRT IS AUTOMATICALLY CHECKED FOR MOVEMENT ONTO CHARACTERS DEFINED
;AS BEING SOLID.  IF SUCH A MOVEMENT TAKES PLACE THE NEW POSITION IS 
;REJECTED. 

;TO USE THIS CALL, LOAD A WITH THE SLOT # AND LOAD X WITH THE CHAR VALUE.
;ANY BACKGROUND CHAR EQUAL TO OR ABOVE THIS VALUE IS CONSIDERED SOLID.
;TO DEACTIVATE THIS FUNCTION YOU MUST CALL INITSPRT.

;A RETURNS A FLAG:
;0 (AND Z) = SUCCESS
;-1 = INVALID SLOT #
;1 = UNUSED SLOT #

SOLID:
	STX	SUBSVAR3	;SAVE SOLID VALUE
	JSR	USEDINDX	;CHECK FOR ERRORS -1 AND 1.
	LDA	SUBSVAR3	;GET BACK SOLID VALUE
	STA	ANIM_RAM+SL,X	;SET NEW SOLID VALUE
	LDA	ANIM_RAM+FB,X
	ORA	#8
	STA	ANIM_RAM+FB,X	;SET ON THE FLAG FOR SOLID DEFINED
	LDA	#0
	RTS

;THIS CALL WILL CAUSE A SPRITE BLOCK OR ANIMATION TO BE DISPLAYED AS
;ITS MIRROR IMAGE OR IT WILL CANCEL THAT FUNCTION.  

;LOAD A WITH THE SLOT NUMBER AND X WITH 0 FOR CANCEL, 1 FOR MIRROR IMAGE.
;A RETURNS A FLAG:
;0 (AND Z) = SUCCESS
;-1 = INVALID SLOT #
;1 = UNUSED SLOT #

MIRROR:	STX	SUBSVAR3	;SAVE FLAG
	JSR	USEDINDX	;CHECK FOR ERRORS -1 AND 1
	LDA	ANIM_RAM+AF,X	;GET AUX FLAGS
	AND	#$BF;#B'10111111	;REMOVE THE MIRROR FLAG
	LDY	SUBSVAR3	;GET BACK MIRROR FLAG
	BEQ	MR10
	ORA	#$40		;IF FLAG SET, SET MIRROR BIT
MR10:	STA	ANIM_RAM+AF,X	;PUT BACK NEW STATE
	JSR	SPFRAME
	LDA	#0
	RTS

;THIS CALL WILL CAUSE A SPRITE BLOCK OR ANIMATION TO BE DISPLAYED UPSIDE
;DOWN FROM ITS ORIGINAL SPECIFICATION.

;LOAD A WITH THE SLOT NUMBER AND X WITH 0 FOR CANCEL, 1 FOR UPSIDE DOWN.
;A RETURNS A FLAG:
;0 (AND Z) = SUCCESS
;-1 = INVALID SLOT #
;1 = UNUSED SLOT #

INVERT:	STX	SUBSVAR3	;SAVE FLAG
	JSR	USEDINDX	;CHECK FOR ERRORS -1 AND 1
	LDA	ANIM_RAM+AF,X	;GET AUX FLAGS
	AND	#$7F		;REMOVE THE INVERT FLAG BIT
	LDY	SUBSVAR3	;GET BACK INVERT FLAG
	BEQ	IN10
	ORA	#$80		;IF FLAG SET, SET INVERT BIT
IN10:	JMP	MR10

;THIS CALL WILL CAUSE A SPRITE OR BACKGROUND ANIMATION TO AUTOMATICALLY
;KILL ITSELF (FREE THE SLOT) AFTER IT HAS COMPLETED THE LAST FRAME.

;LOAD A WITH THE SLOT NUMBER.
;A RETURNS A FLAG:
;0 (AND Z) = SUCCESS
;-1 = INVALID SLOT #
;1 = UNUSED SLOT #

AUTOKILL:
	JSR	USEDINDX	;CHECK FOR ERRORS -1 AND 1
	LDA	ANIM_RAM+AF,X	;GET AUX FLAGS
	ORA	#$20		;SET AUTOKILL FLAG
	STA	ANIM_RAM+AF,X	;PUT BACK NEW STATE
	LDA	#0
	RTS

;THIS CALL WILL CHANGE THE TIME FRAME USED FOR ANIMATION UPDATES.  AT
;THE INITSPRT CALL THE DEFAULT VALUE IS LOADED FROM THE ANIMATION STRUCTURE.
;AFTER THIS YOU MAY CHANGE THE VALUE BY CALLING THIS ROUTINE.  THE NEW
;VALUE DOES NOT TAKE EFFECT UNTIL THE CURRENT VALUE HAS COUNTED DOWN.

;LOAD A WITH THE SLOT # AND X WITH THE NEW VALUE.
;A RETURNS A FLAG:
;0 (AND Z) = SUCCESS
;-1 = INVALID SLOT #
;1 = UNUSED SLOT #

SETSPEED:
	STX	SUBSVAR3
	JSR	USEDINDX	;CHECK FOR ERRORS -1 AND 1
	LDA	SUBSVAR3
	STA	ANIM_RAM+RL,X	;RELOAD THE SPEED
	LDA	#0
	RTS

;THIS CALL WILL RETURN THE CURRENT ANIMATION SPEED IN THE X REGISTER.
;THIS IS THE VALUE THAT YOU MAY CHANGE WITH SETSPEED.  

;LOAD A WITH THE SLOT #.
;A RETURNS A FLAG:
;0 (AND Z) = SUCCESS AND X HAS CURRENT VALUE.
;-1 = INVALID SLOT #
;1 = UNUSED SLOT #

GETSPEED:
	JSR	USEDINDX	;CHECK FOR ERRORS -1 AND 1
	LDA	ANIM_RAM+RL,X	;GET THE RELOAD VALUE (SPEED)
	TAX
	LDA	#0
	RTS

;THIS CALL WILL FREEZE AN ANIMATION SEQUENCE.  WHEN FROZEN, NEITHER TIME
;BASED ANIMATION UPDATES NOR SCREEN ALIGNMENT BASED UPDATES WILL TAKE
;PLACE.  SELFRAME CAN BE USED TO CHANGE THE FRAME.

;LOAD A WITH THE DESIRED SLOT #.
;A RETURNS A FLAG:
;0 (AND Z) = SUCCESS
;-1 = INVALID SLOT #
;1 = UNUSED SLOT #

FREEZE:	JSR	USEDINDX
	ORA	#$40
	STA	ANIM_RAM+FB,X	;IF IN USE, SET FROZEN BIT
	LDA	#0
	RTS

;THIS CALL WILL UNFREEZE AN ANIMATION THAT WAS FROZEN WITH FREEZE.
;LOAD A WITH THE SLOT #.
;A RETURNS A FLAG:
;0 (AND Z) = SUCCESS
;-1 = INVALID SLOT #
;1 = UNUSED SLOT #

UNFREEZE:
	JSR	USEDINDX	;CHECK FOR ERRORS -1 AND 1
	AND	#$BF		;TURN OFF FROZEN BIT
	STA	ANIM_RAM+FB,X	;PUT BACK
	LDA	#0		;RETURN NO ERROR
	RTS

;THIS CALL WILL SELECT THE CURRENT ANIMATION FRAME AND UPDATE THE DISPLAY.
;IT IS BEST TO FREEZE THE ANIMATION OR ENABLE SCREEN ALIGNMENT OF THE 
;FRAME WILL BE OVERWRITTEN AT NEXT TIME BASED UPDATE.   DO NOT SELECT
;AN ILLEGAL FRAME #. IF YOU HAVE 4 FRAMES, YOUR CHOICES ARE 0-3.

;LOAD A WITH THE SLOT # AND X WITH THE DESIRED FRAME.
;A RETURNS A FLAG:
;0 (AND Z) = SUCCESS
;-1 = INVALID SLOT #
;1 = UNUSED SLOT # OR NOT ANIMATION.

SELFRAME:
	STX	SUBSVAR3
	JSR	USEDINDX	;CHECK FOR ERRORS -1 AND 1
	LDA	SUBSVAR3
	STA	ANIM_RAM+FR,X	;SET CURRENT FRAME
	LDA	ANIM_RAM+FB,X
	BMI	SFL9		;IF NOT POSITIONED YET, NO UPDATE

	AND	#3		;KEEP ONLY FRAME TYPE BITS
	CMP	#2		;NOT ANIMATION?
	BCC	SFL10		;IF NOT, A WILL HAVE 1 IN IT AND THATS ERR #.

	BNE	SFL5		;SPRITE ANIMATION?
	JSR	SPFRAME		;IF SO, CALL HERE
	LDA	#0
	RTS

SFL5: 	LDA	ANIM_RAM+NS,X
	ORA	#$80		;IF OBJECT, CAN ONLY SET FLAG
	STA	ANIM_RAM+NS,X	;CAUSE THERE HAS TO BE ROOM ENOUGH
SFL9:  	LDA	#0
	RTS

SFL10:	RTS

;THIS SUBROUTINE WILL TAKE A POINTER TO AN OBJECT BLOCK IN (SUBSVAR1)
;AND WILL RETURN HOW MUCH DATA IT TAKES TO UPDATE THE SCREEN FROM THAT
;OBJECT SPECIFICATION ASSUMING THAT SCBUF WILL BE USED.  IT CHANGES
;ALL REGISTERS.  A RETURNS THE VALUE, CY SET IF > 255.

;THIS ROUTINE ASSUMES THAT THE OBJECT IS NOT ALLOWED TO SPAN PAGES.
;THIS IS A LIMITATION OF THE OBJECT AND ANIMATION ROUTINES SINCE SPANNING
;PAGES REQUIRES MUCH MORE ADDRESSING DATA AND IS SO MUCH SLOWER.

OBJ_BYTES:
	LDY	#2
	LDA	(SUBSVAR1),Y	;GET HEIGHT
	CLC
	ADC	#3
	LSR	A
	LSR	A		;MAKE PALETTE HEIGHT
	TAX
	DEY
	LDA	(SUBSVAR1),Y	;GET WIDTH
	CLC	
	ADC	#3		;ROUND UP FOR PALETTE WIDTH
	LSR	A
	LSR	A		;MAKE BYTES PER PALETTE
	CLC
	ADC	#3		;BUT IT TAKES 3 TO ADDRESS
	TAY
	JSR	MUL		;MAKE AMOUNT TO WRITE OUT ALL PAL INFO
	STX	SUBSVAR4	;SAVE IT HERE

	LDY	#2
	LDA	(SUBSVAR1),Y	;GET HEIGHT AGAIN
	TAX
	DEY
	LDA	(SUBSVAR1),Y	;GET WIDTH
	CLC	
	ADC	#3		;ADD AMOUNT TO ADDRESS IT
	TAY
	JSR	MUL		;MAKE AMOUNT TO WRITE OUT ALL PAL INFO
	TYA
	BNE	OO209		;IF MORE THAN 256, ITS NO GOOD
	TXA
 	CLC
	ADC	SUBSVAR4	;ADD IN AMOUNT FOR PALETTE
	RTS
OO209:	SEC
	RTS


;THIS ROUTINE WILL CALL ANIMINDX AND WILL ALSO CHECK FOR AN UNUSED SLOT #.
;IF THE SLOT # IS INVALID OR UNUSED, THIS ROUTINE WILL NOT RETURN TO YOU,
;IT WILL POP THE STACK AND THEN DO A RTS.  OTHERWISE, IF IT RETURNS TO
;YOU A HAS THE FLAG BYTE AND X HAS THE INDEX.

USEDINDX:
	JSR	ANIMINDX
	BNE	UDX10
	LDA	ANIM_RAM+FB,X
	BEQ	UDX5
	RTS

UDX5:	LDA	#1	;IF UNUSED, RETURN 1 VALUE
UDX10:	TAX		;SAVE ERROR CODE
	PLA		;POP THE RETURN ADDRESS OF CALLER
	PLA		;POP THE RETURN ADDRESS OF CALLER
	TXA
	RTS		;AND RETURN TO HIS CALLER WITH CORRECT ERROR

;THIS ROUTINE WILL CONVERT A SLOT NUMBER IN A INTO AN INDEX IN X.  IT
;ALSO CHECKS FOR IN RANGE.  ON RETURN Z AND A=0 IF VALID.    A=-1 IF INVALID.

ANIMINDX:
	CMP	#SPSLOTS	;VALID VALUE TO FREE UP?
	BCS	AX40		;SKIP IF NOT

	TAX
	LDY	#ANIM_WIDE
	JSR	MUL
	LDA	#0
	RTS

AX40:	LDA	#-1
	RTS

;THIS ROUTINE WILL TAKE AN ANIMATION/SPRITE SLOT INDEX IN X AND UPDATE THE CHAR 
;AND PALETTE INFO. IT ALWAYS PRESERVES THE INUSE AND BEHIND BITS.  
;ITS ONLY FOR SPRITES, NOT OBJECT ANIMATIONS.  

;IF SBL BIT $08 TRUE, THIS ROUTINE WILL REPLACE
;THE IMAGE WITH BLANK CHARS ($FA).

;IT SAVES YOUR X IN ALL CASES.

SPFRAME:
	TXA
	PHA

	LDA	ANIM_RAM+ABL,X		;GET BLINK
     	AND	#$08			;SEE IF TIME TO BLANK
	BEQ	SPF4

;WE ARE BLANKING THIS SPRITE BECAUSE IT IS IN BLINK MODE.  JUST FILL ITS
;CHAR VALUE WITH $FA.

	LDY	ANIM_RAM+NS,X	;GET NUMBER OF SPRITES
	LDA	ANIM_RAM+BS,X	;GET BASE SPRITE
	TAX	
	LDA	#$FA		;GET BLANK CHAR TO FILL WITH

SPF3:	STA	SPRAM+1,X	;SET CHAR INTO SPRITE
	INX
	INX
	INX
	INX
	DEY
	BNE	SPF3		;FILL ALL WITH BLANKS
	PLA
	TAX
	RTS

;WE ARE NOT BLANKING DUE TO BLINK, WE NEED TO PAINT THE FRAME.

SPF4:  	LDA	ANIM_RAM+FB,X
	AND	#$3
	CMP	#1
	BNE	SPF5

	LDA	ANIM_RAM+PTRL,X	;IF JUST SPRITE AND NOT ANIMATION, USE PTR
	STA	SUBSVAR1
	LDA	ANIM_RAM+PTRH,X
	STA	SUBSVAR2
	JMP	SPF25

SPF5:	LDA	ANIM_RAM+FR,X	;GET CURRENT FRAME
	LDY	#0
	ASL	A
	BCC	SPF10
	LDY	#1		;MAKE Y:A=OFFSET IN ANIMATION LIST
SPF10:	CLC
	ADC	#3		;AND NEED TO SKIP FLAG BYTES
	BCC	SPF20
	INY			;MOVE UP ANY CARRY
SPF20:	CLC
	ADC	ANIM_RAM+PTRL,X	;ADD IN THE LOW POINTER
	STA	SUBSVAR1
	TYA
	ADC	ANIM_RAM+PTRH,X	;ADD IN HIGH
	STA	SUBSVAR2	;NOW HAVE POINTER TO THE NEXT FRAME'S OFFSET
	LDY	#0
	LDA	(SUBSVAR1),Y	;GET LOW
	PHA
	INY
	LDA	(SUBSVAR1),Y	;GET HIGH
	STA	SUBSVAR2
	PLA
	STA	SUBSVAR1	;NOW HAVE POINTER TO THE DATA

;SUBSVAR1 POINTS TO THE SPRITE DATA, X STILL HAS THE INDEX FOR THE SPRITE
;SLOT.  SET UP OUR LOOP VARIABLES BASED ON WHETHER WE ARE INVERTING OR
;MIRRORING.

;WE MAKE A VALUE TO ADD TO FOR EACH MOVEMENT UP OR DOWN, A VALUE TO
;ADD AT THE END OF EACH ROW, AND WE SET UP A COUNT OF ROWS AND A WIDTH
;FOR EACH ROW.

SPF25: 	LDY	#1		;POINT TO WIDTH OF SPRITE
	LDA	(SUBSVAR1),Y
	STA	MATH1		;SAVE HERE
	INY			;POINT TO HEIGHT
	LDA	(SUBSVAR1),Y
	STA	MATH2		;SAVE HERE AS LOOP COUNTER
	INY			;POINT TO DATA

	LDA	ANIM_RAM+AF,X	;GET INVERT/MIRROR STATE
	AND	#$C0		;KEEP THESE BITS
	STA	MATH3		;SAVE HERE
	BMI	SPF30		;SKIP

;NOT INVERTED, NOT MIRRORED

	AND	#$40		;SEE IF MIRRORED
	BNE	SPF28
	LDA	#4
	STA	SUBSVAR3	;4 BEFORE EACH SPRITE
	LDA	#0
	STA	SUBSVAR4	;0 AT EACH ROW'S END
	LDA	ANIM_RAM+BS,X	
	SEC
	SBC	#4		;START 4 DOWN
	TAX
	JMP	SPF50		;GO DO IT

;NOT INVERTED, BUT IT IS MIRRORED.

SPF28:	LDA	#-4
	STA	SUBSVAR3	;-4 BEFORE EACH SPRITE
	LDA	MATH1
	ASL	A
	ASL	A		;MAKE WIDTH*4
	STA	MATH4
	ASL	A
	STA	SUBSVAR4	;2*WIDTH*4 PER SPRITE AT EACH ROW'S END
	LDA	MATH4		;GET WIDTH*4
	CLC
	ADC	ANIM_RAM+BS,X	;START 1 ROW UP
	TAX
	JMP	SPF50		;GO DO IT

;INVERTED

SPF30:	AND	#$40		;SEE IF MIRRORED
	BNE	SPF35	

	LDA	#4
	STA	SUBSVAR3	;4 BEFORE EACH SPRITE
	LDA	MATH1
	ASL	A
	ASL	A
	STA	MATH4
	ASL	A
	EOR	#$FF
	STA	SUBSVAR4	;-2*WIDTH AT EACH ROW'S END
	INC	SUBSVAR4	;NEED INC TO GET NEGATIVE

	LDA	ANIM_RAM+NS,X
	ASL	A
	ASL	A
	CLC
	ADC	ANIM_RAM+BS,X	;POINT TO END
	SEC
	SBC	#4		
	SEC
	SBC	MATH4
	TAX	     		;START AT END-WIDTH*4-4
	JMP	SPF50		;GO DO IT

;INVERTED AND MIRRORED

SPF35:	LDA	#-4
	STA	SUBSVAR3	;-4 BEFORE EACH SPRITE
	LDA	#0
	STA	SUBSVAR4	;0 AT EACH ROW'S END
	LDA	ANIM_RAM+NS,X
	ASL	A
	ASL	A
	CLC
	ADC	ANIM_RAM+BS,X	;POINT TO END
	TAX	     		;START AT END

;NOW:
;X POINTS TO THE STARTING SPRITE (BEFORE START OF LOOP CORRECTION),
;MATH1=WIDTH
;MATH2=HEIGHT
;MATH3=INVERT/MIRROR BITS
;SUBSVAR3=CORRECTION BEFORE EACH SPRITE
;SUBSVAR4=END OF ROW CORRECTION

SPF50: 	LDA	MATH1
	STA	MATH4		;SET A LOOP COUNT FOR THE ROW

SPF60:	TXA
	CLC
	ADC	SUBSVAR3	;CORRECT TO NEXT SPRITE
	TAX
	LDA	(SUBSVAR1),Y	;GET CHAR TO USE
	STA	SPRAM+1,X	;SET CHAR INTO SPRITE
	INY			;POINT TO PAL/FLIP INFO
	LDA	SPRAM+2,X	;GET THE BEHIND BIT
	AND	#$20		;KEEP IT
	ORA	#8		;ALWAYS SET IN USE FOR INITSPRT
	ORA	(SUBSVAR1),Y	;MOVE INTO PAL INFO
	EOR	MATH3		;TOGGLE MIRROR/INVERT BITS CONDITION
	STA	SPRAM+2,X	;SAVE BACK OUT
	INY			;SKIP TO NEXT SPRITE
	DEC	MATH4		;COUNT 1 MORE ON THIS ROW
	BNE	SPF60

	TXA			;TIME TO CORRECT FOR ROW
	CLC
	ADC	SUBSVAR4
	TAX

	DEC	MATH2		;WHEN ROW IS DONE, COUNT 1 MORE ROW
	BNE	SPF50

	PLA
	TAX
	RTS

;THIS ROUTINE WILL TAKE AN OBJECT ANIMATION SLOT INDEX IN X AND UPDATE THE 
;SCREEN POSITIONS IN USE BY THAT OBJECT.  IT SAVES X.  IT DOES NOT
;CHECK FOR ENOUGH ROOM, THE CALLER SHOULD DO THAT.

OBJFRAME:
	TXA
	PHA

	LDA	ANIM_RAM+BS,X
	AND	#$F
	ASL	A
	ASL	A		;MAKE X LOCATION
	STA	XOBJ

	LDA	ANIM_RAM+BS,X
	AND	#$F0
	LSR	A
	LSR	A
	STA	YOBJ		;MAKE Y LOCATION

	LDA	ANIM_RAM+FR,X	;GET CURRENT FRAME
	LDY	#0
	ASL	A
	BCC	OBF10
	LDY	#1		;MAKE Y:A=OFFSET IN ANIMATION LIST
OBF10:	CLC
	ADC	#3		;AND NEED TO SKIP FLAG BYTES
	BCC	OBF20
	INY			;MOVE UP ANY CARRY
OBF20:	CLC
	ADC	ANIM_RAM+PTRL,X	;ADD IN THE LOW POINTER
	STA	SUBSVAR1
	TYA
	ADC	ANIM_RAM+PTRH,X	;ADD IN HIGH
	STA	SUBSVAR2	;NOW HAVE POINTER TO THE NEXT FRAME'S OFFSET
	LDY	#0
	LDA	(SUBSVAR1),Y	;GET LOW
	TAX
	INY
	LDA	(SUBSVAR1),Y	;GET HIGH
	TAY
	JSR	PUTOBJ		;PUT DOWN THE OBJECT
	PLA
	TAX			;RESTORE USER'S X
	RTS
	
;THIS ROUTINE WILL TAKE A VIDEO SET REQUEST IN A AND USE IT TO SELECT
;THE VIDEO PAGE AND SET ROMPAGE.  IT CHANGES A AND X.

SEL_VPAGE:
	ROL	A
	ROL	A
	ROL	A		;MOVE SET # UP INTO VIDEO SET NIBBLE
	AND	#$F0		;KEEP ONLY VIDEO BITS
	PHA			;SAVE A COPY
	LDA	ROMPAGE
	AND	#$F		;SAVE ROM BITS
	STA	ROMPAGE
	PLA
	ORA	ROMPAGE
	STA	ROMPAGE
	JSR	SELPAGE		;SELECT THE PAGE ACCORDING TO ROM OR ROMLESS
	RTS

;THIS ROUTINE WILL CHECK IF ANY ANIMATIONS NEED SERVICING.  IT GOES THROUGH
;THE ANIMATION SLOTS AND LOOKS FOR THOSE ACTIVE WITH AN ANIMATION.  IT
;SHOULD BE CALLED EACH NMI.

CHECK_ANIM:

	LDX	#0		;POINT TO THE SLOTS
	LDY	#SPSLOTS	;GET COUNT TO CHECK

;CHECK AND PROCESS EACH SLOT.

CA10: 	TYA
	PHA			;SAVE LOOP COUNT
	LDA	ANIM_RAM+FB,X	;GET THE FLAG BYTE
	AND	#$3		;KEEP ONLY ID BITS
	TAY			;KEEP COPY HERE
	BNE	CA20		;SKIP IF TRUE.  MEANS SLOT IN USE.

CA15: 	PLA
	TAY			;GET BACK LOOP COUNT
	TXA
	CLC
	ADC	#ANIM_WIDE	;SKIP TO NEXT
	TAX
	DEY
	BNE	CA10
	RTS

;FOUND A USED SLOT.  IF FLASHING, COUNT DOWN THE FLASH.

CA20:	LDA	ANIM_RAM+ABL,X	;GET FLASH COUNTER.  ONLY EVER TRUE IF SPRITE
	BEQ	CA21
	DEC	ANIM_RAM+ABL,X	;LOWER THE COUNT
	LDA	ANIM_RAM+ABL,X	;GET RESULT
	AND	#$07		;MAKE 1/8 SECOND HALF FREQUENCY
	BNE	CA21
	TYA
	PHA
	JSR	SPFRAME		;IF ITS AN EVEN 1/4 SECOND, NEED TO CHANGE IT
	PLA
	TAY

;NOT FLASHING.  IF JUST SPRITE (1) DO NOTHING.

CA21:	TYA
 	CMP	#1
	BEQ	CA15

;ITS AN ANIMATION.  SEE IF FROZEN OR IF ALIGNMENT BY X OR Y.  IF NOT, COUNT 
;IT DOWN.

	LDA	ANIM_RAM+FB,X
	AND	#$70
	BEQ	CA25
	TYA				;GET BACK TYPE
	JMP	CA40			;IF NOT COUNTING, NEED UPDATE ANYWAY?	

CA25:	DEC	ANIM_RAM+CN,X
	BNE	CA40

;ANIMATION WENT TO ZERO.  IF BACKGROUND ANIMATION, SET REFRESH NEEDED FLAG.

	TYA
	CMP	#3
	BNE	CA30
	LDA	ANIM_RAM+NS,X
	ORA	#$80
	STA	ANIM_RAM+NS,X

;RELOAD THE FREQUENCY AND MOVE FRAME TO NEXT.

CA30: 	LDA	ANIM_RAM+RL,X
	STA	ANIM_RAM+CN,X
	LDA	ANIM_RAM+PTRL,X
	STA	NMI_PTR
	LDA	ANIM_RAM+PTRH,X
	STA	NMI_PTR+1

	INC	ANIM_RAM+FR,X	;INC FRAME
	LDA	ANIM_RAM+FR,X	;GET IT
	LDY	#1		;POINT TO THE FRAMES IN DEFFINITION
	CMP	(NMI_PTR),Y	;HIT END OF LIST?
	BNE	CA35
	LDA	#0
	STA	ANIM_RAM+FR,X	;RESET IF TOO BIG
	LDA	ANIM_RAM+AF,X	;IF HAVE TO WRAP, AUTOKILL ENABLED?
	AND	#$20		;AUTOKILL?
	BEQ	CA35
	JSR	MANUAL_KILL	
	JMP	CA15

;WE COUNTED DOWN.  IF SPRITE, UPDATE FRAME.

CA35:	LDA	ANIM_RAM+FB,X
	AND	#3
	CMP	#2
	BNE	CA40
	JSR	SPFRAME		;THIS ROUTINE WILL DO IT
CA37:	JMP	CA15		;AND NOT A BACKGROUND FOR SURE.

;SEE IF A BACKGROUND NEEDS REFRESHING.

CA40:	CMP	#3		;BACKGROUND?
	BNE	CA37
	LDA	ANIM_RAM+NS,X
	BPL	CA37

;A BACKGROUND ANIMATION NEEDS REFRESHING.  TRY TO FIT IT IN.  IF WE CAN'T,
;WE HAVE TO DO IT NEXT PASS.

	AND	#$7F		;GET AMOUNT OF RAM REQUIRED
	STA	SUBSVAR4
	JSR	GET_ROOM	
	CMP	SUBSVAR4	;ENOUGH ROOM TO DO THIS UPDATE?
	BCC	CA37		;IF NOT ENOUGH, IGNORE THIS PASS

;WE HAVE ENOUGH ROOM TO UPDATE THIS OBJECT FRAME.  
	
	JSR	OBJFRAME
	LDA	ANIM_RAM+NS,X	
	AND	#$7F
	STA	ANIM_RAM+NS,X	;RESET FLAG OF NEED UPDATE
	JMP	CA15

;THESE ARE THE 2 BYTES TO LOAD INTO THE LOW REGISTERS FOR A GIVEN INSTRUMENT.
;THE SOUND FLAG BYTES SPECIFY THE INSTRUMENT AND THAT IS CONVERTED INTO
;A *4 INDEX FOR USE HERE.  IF THE VOICE IS 3 OR 4 THEN THESE VALUES DO NOT
;REALLY MAKE SENSE. 

INSTRUMENTS:	

.byte	$C0,$00          		;BASE_HARPSI
.byte	$C0,$00          		;HARPSI
.byte	$C0,$00          		;HIGH_HARPSI    
.byte	$80,$00          		;BASE_STRING
.byte	$80,$00          		;STRING
.byte	$80,$00          		;HIGH_STRING    
.byte	$00,$00          		;BASE_ELECPIANO
.byte	$00,$00          		;ELECPIANO
.byte	$00,$00          		;HIGH_ELECPIANO
.byte	$80,$FF          		;BASE_SLIDER
.byte	$80,$FF          		;SLIDER
.byte	$80,$FF          		;HIGH_SLIDER   
.byte	$00,$D6          		;BASE_BEE
.byte	$00,$D6          		;BEE
.byte	$00,$D6          		;HIGH_BEE
.byte	$40,$00          		;BASE_PIANO
.byte	$40,$00          		;PIANO
.byte	$40,$00          		;HIGH_PIANO
.byte 	$80,$C9			;BASE_ARCADE
.byte 	$80,$C9			;ARCADE
.byte 	$80,$C9			;HIGH ARCADE

;THIS ROUTINE WILL GO THROUGH THE SOUND SLOTS AND WILL FEED THE NEXT
;CORRECT DATA TO THE SOUND CHIP ACCORDING TO THE ACTIVE SLOTS.  IT SHOULD
;BE CALLED EACH NMI.

FEED_SOUND:

	LDX	#0		;START WITH THE LOWEST SOUND SLOT.
	
FS20:	LDA	SND_RAM+SF,X	;GET THE SOUND FLAG
	BPL	FS30		;IF NOT IN USE, SKIP IT

;FOUND A SOUND THAT IS RUNNING.  COUNT DOWN ITS TIMER.

	DEC	SND_RAM+ST,X	;COUNT IT DOWN
	BEQ	FS50		;IF REACHES ZERO, TIME FOR MORE PROCESSING	

;DONE WITH THIS SOUND, OR NOT IN USE.

FS30:	TXA
	CLC
	ADC	#SND_WIDE
	TAX
	CMP	#SND_WIDE*SNDSLOTS	;END OF LIST?
	BCC	FS20			;IF NOT, CONTINUE
	RTS

;THIS SOUND NEEDS TO BE UPDATED.  ITS TIMER RAN OUT.

FS50:  	LDA	SND_RAM+SOL,X		;GET LOW OFFSET OF NEXT BYTE TO USE
	STA	SUBSVAR1
	LDA	SND_RAM+SOH,X		;GET HIGH
	STA	SUBSVAR2		;MAKE POINTER TO THE NEXT BYTE
	LDY	#0

;PROCESS NEXT COMMAND FOR THIS SOUND SLOT.

FS60:	LDA	(SUBSVAR1),Y
	AND	#$E0;#B'11100000		;SEE IF JUST A NOTE
	CMP	#$A0;#B'10100000		;NOTES END BELOW THIS
	BCS	FS200

;JUST ANOTHER NOTE TO PLAY.

	LDA	(SUBSVAR1),Y		;GET BACK DURATION
	JSR	SET_DURATION

	LDA	SND_RAM+SI,X		;GET INSTRUMENT TYPE
	ASL	A			;MAKE *2 POINTER
	TAY
	LDA	FREQBASES,Y		;GET LOW BASE OF FREQUENCY TABLE
	STA	NMI_PTR
	LDA	FREQBASES+1,Y
	STA	NMI_PTR+1		;MAKE POINTER TO FREQUENCY TABLE
	LDY	#0
	LDA	(SUBSVAR1),Y		;GET NOTE TO USE
	AND	#$1F
	CMP	#PAUSE			;SILENCE?
	BEQ	FS70
	ASL	A			;MAKE INDEX FROM IT
	TAY
	LDA	(NMI_PTR),Y
	STA	SUBSVAR3
	INY
	LDA	(NMI_PTR),Y
	STA	SUBSVAR4		;SET FREQUENCY TO USE
	JSR	SET_FREQUENCY
FS70:  	JSR	INC_INDX
	JMP	FS30
	
;ITS A SPECIAL COMMAND.

FS200:	CMP	#$A0;#B'10100000	;SELECT INSTRUMENT?
	BNE	FS220
	LDA	(SUBSVAR1),Y	;GET BACK INSTRUMENT
	AND	#$1F
	STA	SND_RAM+SI,X	;PUT INTO SLOT
	LDA	SND_RAM+SF,X	;SEE IF SUSPENDED OR NO BASE
	AND	#$60
	BNE	FS210
	JSR	INITSND		;INITIALIZE FOR THIS INSTRUMENT

;DONE WITH THIS SOUND AND NEED TO INC THE POINTER AND PUT IN A 1 NMI DELAY.

FS210:	JSR	INC_INDX
	LDA	#1
	STA	SND_RAM+ST,X	;SET TIMER FOR NEXT NMI
	JMP	FS30
	
;ABSOLUTE FREQUENCY LOAD?

FS220:	CMP	#$C0;#B'11000000	;LOAD FREQUENCY?
	BNE	FS240

	LDA	(SUBSVAR1),Y	;GET NOTE DURATION
	ASL	A
	ASL	A
	ASL	A		;MOVE NOTE DURATION INTO NORMAL LOCATION
	JSR	SET_DURATION

	LDY	#0
	LDA	(SUBSVAR1),Y	;GET HIGH FREQUENCY 2 BITS
	AND	#3
	STA	SUBSVAR4
	INY
	LDA	(SUBSVAR1),Y	;GET LOW FREQUENCY BYTE
	STA	SUBSVAR3	;SAVE IT

	JSR	SET_FREQUENCY	;SET FREQUENCY.  WILL CAUSE IT TO PLAY
	JSR	INC_INDX
	JSR	INC_INDX
	JMP	FS30

;EXTENDED COMMAND.

FS240:	LDA	(SUBSVAR1),Y	;GET THE EXTENDED BITS
	AND	#%00011111	;KEEP THEM AND THE DATA BITS TOO.
	CMP	#%00000011+1	;SEE IF SPECIFY VOICE COMMAND
	BCS	FS260

	AND	#3		;GET THE VOICE TO USE
	ASL	A
	ASL	A		;MAKE *4 BASE POINTER

FS245: 	PHA			;SAVE VOICE BASE BITS
	LDA	SND_RAM+SF,X	;GET CURRENT VALUE
	AND	#$E0		;REMOVE THE BITS THAT SELECT THE BASE REG
	STA	SND_RAM+SF,X
	PLA
	ORA	SND_RAM+SF,X	;PUT NEW REGISTER BASE INTO THE FLAG BYTE
	AND	#$9F		;REMOVE REGISTER NOT SELECTED BIT AND SUSPEND
	STA	TMP_NMI1	;SAVE HERE FOR CHECK FOR OTHER'S USING IT
	STA	SND_RAM+SF,X
	STX	TMP_NMI2	;SAVE OUR INDEX

	LDX	#0
FS250:	LDA	SND_RAM+SF,X	;GET A FLAG BYTE
	EOR	TMP_NMI1	;SEE IF THAT SOUND SLOT IS USING THIS VOICE
	BNE	FS255
      	LDA	SND_RAM+SF,X
	ORA	#$20		;IF SO, SUSPEND HIM
	STA	SND_RAM+SF,X
FS255:	TXA
	CLC
	ADC	#SND_WIDE
	TAX
	CMP	#SND_WIDE*SNDSLOTS	;DONE?
	BCC	FS250

	LDX	TMP_NMI2	;GET BACK OUR INDEX
	LDA	TMP_NMI1	;AND OUR FLAG BYTE
	STA	SND_RAM+SF,X	;PUT BACK OUR FLAG CAUSE OUR LOOP SUSPENDED US
	JSR	ENABLE_VOICE	;AND ENABLE OUR VOICE
	JMP	FS210

FS260:	CMP	#%00000111+1	;REPEAT LIST?
	BCS	FS280
	LDA	SND_RAM+SBL,X
	STA	SND_RAM+SOL,X
	LDA	SND_RAM+SBH,X
	STA	SND_RAM+SOH,X	;IF SO, JUST RESET POINTER
	JMP	FS210		;AND SKIP THIS COMMAND.


FS280:	CMP	#%00001011+1	;END LIST?
	BCS	FS300
	TXA
	PHA
	JSR	S20		;USE THE SILENCE ROUTINE'S SPECIAL ENTRY PNT.
	PLA
	TAX
	JMP	FS210

FS300:	CMP	#%00001111+1	;ABSOLUTE REG LOAD?
	BCS	FS320

	LDA	SND_RAM+SF,X
	AND	#$60
	BNE	FS311		;SKIP IT IF NOT SELECTED OR SUSPENDED

FS310:	LDA	SND_RAM+SF,X	;GET REG BASE FOR THIS VOICE
	AND	#$1F		;KEEP THE REG OFFSET
	STA	SUBSVAR3
	LDY	#0
	LDA	(SUBSVAR1),Y	;GET LOW 2 BITS OF REG TO USE
	AND	#3
	CLC
	ADC	SUBSVAR3	;MAKE IT INTO A POINTER
	STA	NMI_PTR
	LDA	#$40
	STA	NMI_PTR+1	;AND POINT TO THE REG AT 40XX
	LDY	#1
	LDA	(SUBSVAR1),Y	;GET VALUE TO USE
	LDY	#0
	STA	(NMI_PTR),Y	;PUT IT OUT THERE
FS311:	JSR	INC_INDX		;SKIP THE EXTRA BYTE WE USED
	JMP	FS210	

FS320:	CMP	#%00010011+1	;DISABLE SOUND?
	BCS	FS340
	JSR	DISABLE_VOICE
	JMP	FS210

FS340:	CMP	#%00010111+1	;ENABLE SOUND?
	BCS	FS360
	JSR	ENABLE_VOICE
	JMP	FS210

FS360:	CMP	#COMPLEX & %00011111 	;USE COMPLEX VOICE?
	BNE	FS365
	LDA	#$10		;ITS BASE IS HERE
	JMP	FS245		;SHARE CODE WITH THE OTHER VOICE LOGIC

FS365:	CMP	#LOADALL & %00011111	;LOAD ALL REGS?
	BNE	FS380

	LDA	SND_RAM+SF,X
	AND	#$60
	BNE	FS367		;SKIP IT IF NOT SELECTED OR SUSPENDED

	LDA	SND_RAM+SF,X	;GET REG BASE FOR THIS VOICE
	AND	#$1F		;KEEP THE REG OFFSET
	STA	NMI_PTR
	LDA	#$40
	STA	NMI_PTR+1	;AND POINT TO THE REG AT 40XX

	LDY	#1
FS366:	LDA	(SUBSVAR1),Y	;GET VALUE TO USE
	DEY
	STA	(NMI_PTR),Y	;PUT IT INTO THE CORRECT REGISTER
	INY
	INY
	CPY	#5
	BNE	FS366

FS367:	JSR	INC_INDX		;SKIP THE EXTRA BYTES WE USED
	JSR	INC_INDX		
	JSR	INC_INDX		
	JSR	INC_INDX		
	JMP	FS210	

;COMMAND NOT RECOGNIZED.  JUST SKIP IT.

FS380:	JMP	FS210

;THIS ROUTINE WILL TAKE A SOUND SLOT INDEX IN X AND ENABLE THE APPROPRIATE
;BIT IN THE SOUND ENABLE REGISTER TO MAKE THOSE REGISTERS ACTIVE.

ENABLE_VOICE:

	JSR	ENABLE_BIT
	ORA	REG4015
	STA	REG4015
	STA	$4015		;ENABLE IT AND SAVE VALUE FOR OTHERS TO REF.
	RTS

;THIS ROUTINE WILL DISABLE A VOICE SIMILAR TO ENABLE VOICE.

DISABLE_VOICE:
	JSR	ENABLE_BIT
	EOR	#$FF
	AND	REG4015
	STA	REG4015
	STA	$4015		;DISABLE IT AND SAVE STATE	
	RTS

;THIS ROUTINE WILL PUT AN ENABLE REGISTER BIT VALUE INTO A FOR THE SOUND
;SLOT INDEX IN X.  THIS VALUE IS FOR REG4015.

ENABLE_BIT:
	LDA	SND_RAM+SF,X	;GET THE REGISTERS TO USE
	AND	#$1F
	LSR	A
	LSR	A		;MAKE INTO UNIQUE NUMBER 0-4
	TAY
	LDA	#1
	INY
EB10:	DEY
	BEQ	EB20
	ASL	A   		;SHIFT UP ENABLE BIT
     	JMP	EB10
EB20:	RTS


;THIS TABLE HAS A 2 BYTE VALUE FOR EACH NOTE DURATION.  THIS FIRST IS
;THE NUMBER OF NMI CYCLES WE SHOULD WAIT FOR THE NOTE TO COMPLETE.
;THE SECOND IS THE VALUE TO PUT INTO THE SOUND CHIP DURATION REGISTER BITS.

TIME_BASE:
.byte	8,1			;1/16 NOTE
.byte	16,5			;1/8 NOTE
.byte	32,8			;1/4 NOTE
.byte	64,15			;1/2 NOTE
.byte	128,31			;WHOLE NOTE

;THIS ROUTINE WILL TAKE A NOTE DURATION (1/16, 1/8, 1/4, ETC) AS SPECIFIED
;IN THE TOP 3 BITS OF A AND WILL SET THE TIME COUNTER VALUE IN
;THE SOUND SLOT AND WILL ALSO SET UP THE SOUND REGISTER RESPONSIBLE FOR
;THE TIME.  THE SLOT INDEX MUST BE IN X.  THE VALUES IN THE HIGH 3 BITS OF 
;A SHOULD RANGE FROM B'000 TO B'100.  IF THE SLOT IS SUSPENDED OR THE
;REGISTERS ARE NOT SELECTED, THIS ROUTINE WILL SET UP ONLY THE TIME
;BASE AND WILL NOT DO AN ACTUAL LOAD.

;X IS SAVED BUT Y IS NOT.  SUBSVARs ARE NOT DISTURBED.    NMI LEVEL
;ROUTINE ONLY!

SET_DURATION:

	LSR	A
	LSR	A
	LSR	A
	LSR	A		;MOVE BITS DOWN TO MAKE *2 INDEX
	AND	#$FE		;MAKE SURE INDEX IS EVEN
	TAY			;USE INDEX HERE
	LDA	TIME_BASE,Y	;GET THE TIME BASE FOR OUR SOUND STRUCTURE
	STA	SND_RAM+ST,X	;RELOAD THE TIMER

	LDA	SND_RAM+SF,X	;GET BACK THE FLAG
	AND	#$60		;SEE IF SUSPENDED OR NO REGS SELECTED
	BNE	SD60

	INY
	LDA	TIME_BASE,Y	;GET THE RELOAD BITS FOR THE LOW REGISTER
	STA	TMP_NMI1	;SAVE IT HERE

	LDA	SND_RAM+SF,X	;GET REGISTER BASE
	AND	#$1F		;MAKE BASE REG
	STA	NMI_PTR
	LDA	#$40
	STA	NMI_PTR+1	;INTO A POINTER WE CAN USE

	LDA	SND_RAM+SI,X	;GET INSTRUMENT
	ASL	A		;MAKE *2 POINTER FROM IT
	TAY
	LDA	INSTRUMENTS,Y	;GET REGISTER VALUE TO LOAD
	ORA	TMP_NMI1	;OR IN THE TIME BASE
	LDY	#0
	STA	(NMI_PTR),Y	;PUT INTO THE SOUND CHIP
SD60:	RTS

;THE FOLLOWING TABLE HAS A 1 WORD PTR TO THE FREQUENCY TABLE TO USE
;FOR A GIVEN INSTRUMENT.  THE INSTRUMENTS REPEAT THEIR RANGES IN 3'S
;SO ACTUALLY THE TABLE REPEATS A WHOLE LOT.

FREQBASES:

.word 	LOW_FREQ,MID_FREQ,HIGH_FREQ
.word 	LOW_FREQ,MID_FREQ,HIGH_FREQ
.word 	LOW_FREQ,MID_FREQ,HIGH_FREQ
.word 	LOW_FREQ,MID_FREQ,HIGH_FREQ
.word 	LOW_FREQ,MID_FREQ,HIGH_FREQ
.word 	LOW_FREQ,MID_FREQ,HIGH_FREQ
.word 	LOW_FREQ,MID_FREQ,HIGH_FREQ
.word 	LOW_FREQ,MID_FREQ,HIGH_FREQ
.word 	LOW_FREQ,MID_FREQ,HIGH_FREQ
.word 	LOW_FREQ,MID_FREQ,HIGH_FREQ
.word 	LOW_FREQ,MID_FREQ

;THIS TABLE CONTAINS THE FREQUENCIES TO USE FOR SPECIFIC NOTES IN
;A MULTI-OCTIVE RANGE.  THERE ARE 3 REFERENCE POINTS INTO THE TABLE
;FOR USE WITH THE VARIOUS INSTRUMENTS.

LOW_FREQ:
.word 	$352		;C	
.word 	$325		;C#	
.word 	$2FD		;D	
.word 	$2CC		;Eb	
.word 	$2A7		;E	
.word 	$27C		;F	
.word 	$25A		;F#	
.word 	$23B		;G	
.word 	$213		;Ab	
.word 	$1FD		;A	
.word 	$1DE		;Bb	
.word 	$1C6		;B	

MID_FREQ:
.word 	$1AB		;C	
.word 	$191		;C#	
.word 	$17A		;D	
.word 	$167		;Eb	
.word 	$151		;E	
.word 	$13F		;F	
.word 	$12C		;F#	
.word 	$11C		;G	
.word 	$10D		;Ab	
.word 	$FE 		;A	
.word 	$EF 		;Bb	
.word 	$E2 		;B	

HIGH_FREQ:
.word 	$D5  		;MIDDLE C	
.word 	$C8		;C#	
.word 	$BE		;D	
.word 	$B3		;Eb	
.word 	$A9		;E	
.word 	$9F		;F	
.word 	$96		;F#	
.word 	$8E		;G	
.word 	$86		;Ab	
.word 	$7E		;A	
.word 	$77		;Bb	
.word 	$70		;B	
.word 	$6A		;C	
.word 	$64		;C#	
.word 	$5E		;D	
.word 	$59		;Eb	
.word 	$54		;E	
.word 	$4F		;F	
.word 	$4B		;F#	
.word 	$46		;G	
.word 	$42		;Ab	
.word 	$3F		;A	
.word 	$3B		;Bb	
.word 	$38		;B	
.word 	$34		;C	
.word 	$32		;C#	
.word 	$2F		;D	
.word 	$2C		;Eb	
.word 	$29		;E	
.word 	$27		;F	
.word 	$24		;F#	
.word 	$23		;G	

;THIS ROUTINE WILL TAKE A FREQUENCY IN SUBSVAR3 AND 4 AND WILL LOAD
;IT INTO THE SOUND CHIP POINTED TO BY THE SLOT INDEX IN X.  IT JUST
;RETURNS IF THE REGISTERS ARE NOT SELECTED OR THE SOUND IS SUSPENDED.

SET_FREQUENCY:

	LDA	SND_RAM+SF,X	;GET BACK THE FLAG
	AND	#$60		;SEE IF SUSPENDED OR NO REGS SELECTED
	BNE	SQ60

	LDA	SND_RAM+SF,X	;GET REGISTER BASE
	AND	#$1F		;MAKE BASE REG
	STA	NMI_PTR
	LDA	#$40
	STA	NMI_PTR+1	;INTO A POINTER WE CAN USE

	LDY	#2		;START WITH LOW REG LOAD
	LDA	SUBSVAR3
	STA	(NMI_PTR),Y
	INY
	LDA	SUBSVAR4	;THEN GET HIGH
	ORA	#8		;OR IN THE BIT TO USE DURATION REG
	STA	(NMI_PTR),Y
SQ60:	RTS

;THIS ROUTINE WILL INCREMENT THE CURRENT SOUND OFFSET POINTER IN THE
;SOUND SLOT SPECIFIED BY INDEX IN X.

INC_INDX:
	INC	SND_RAM+SOL,X	;DONE, MOVE INDEX ALONG
	BNE	IX5
	INC	SND_RAM+SOH,X
IX5:	RTS


;THIS ROUTINE WILL TAKE A SLOT INDEX IN X (NOT A SLOT #) AND WILL USE
;THE INSTRUMENT SPECIFICATION TO INITIALIZE THAT REGISTER SET.  MAKE SURE
;THAT THE REGISTER SET SPECIFICATION IS VALID, NOT SUSPENDED, AND THAT
;THE INSTRUMENT IS VALID, THIS ROUTINE DOES NOT CHECK THAT.

;YOUR INDEX IN X IS SAVED.  SUBSVARs ARE ALL CHANGED.

INITSND:
	LDA	SND_RAM+SI,X	;GET INSTRUMENT
	ASL	A		;MAKE *2 POINTER FROM IT
	STA	SUBSVAR4	;SAVE IT HERE
	LDA	SND_RAM+SF,X	;GET BASE
	AND	#$1F
	STA	SUBSVAR1
	LDA	#$40
	STA	SUBSVAR2	;MAKE FULL POINTER TO IT IN MEMORY

 	LDY	SUBSVAR4
	LDA	INSTRUMENTS,Y	;GET REGISTER VALUE TO LOAD
	LDY	#0
	STA	(SUBSVAR1),Y	;PUT INTO CORRECT REGISTER
	LDY	SUBSVAR4
	INY			;GET NEXT REGISTER VALUE
	LDA	INSTRUMENTS,Y
	LDY	#1
	STA	(SUBSVAR1),Y	;PUT INTO NEXT REG
	JSR	ENABLE_VOICE
	RTS

;THIS ROUTINE WILL CONVERT A SOUND SLOT NUMBER IN A INTO AN INDEX IN X.  IT
;ALSO CHECKS FOR IN RANGE.  ON RETURN Z AND A=0 IF VALID.    

SNDINDX:
	CMP	#SNDSLOTS	;VALID VALUE?
	BCS	SX40		;SKIP IF NOT

	TAX
	LDY	#SND_WIDE
	JSR	MUL
	LDA	#0
	RTS

SX40:	LDA	#-1
	RTS

;THIS ROUTINE IS CALLED EACH NMI TO PROCESS THE CURRENT PALETTE.  IT
;MUST BE CALLED AHEAD OF OTHER ROUTINES THAT WRITE TO SCREEN IN ORDER
;TO GUARANTEE IT CAN PUT ITS DATA (38 MAX) INTO THE SCREEN BUFFER.


DOPAL:	LDA	NEW_PAL		;SEE IF NEED INIT OF NEW PAL
	AND	#1
	BEQ	DP100

;INITIALIZING A NEW BACKGROUND PALETTE.

	EOR	NEW_PAL
	STA	NEW_PAL		;RESET BIT OF NEED INIT OF BACKGROUND
	LDY	#0
	LDA	(BPAL_BASE),Y
	STA	BPAL_BLINK	;SET BLINK FOR BACKGROUND
	INY
	LDA	(BPAL_BASE),Y
	STA	BPAL_DEPTH	;SET DEPTH OF BLINK
	INY
	LDA	#1
	STA	BPAL_INDX	;SET BLINK INDEX TO NEXT FRAME CAUSE 0 BOOTS.
	LDA	(BPAL_BASE),Y
	STA	BPAL_FREQ	;SET FREQUENCY
	STA	BPAL_CNT	;AND SET TIMER COUNT
	
	CLC
	LDA	BPAL_BASE
	ADC	#3
	STA	BPAL_BASE
	LDA	BPAL_BASE+1
	ADC	#0
	STA	BPAL_BASE+1	;POINT BASE DIRECTLY TO DATA

	LDX	SCCNT		;GET SCREEN BUFFER COUNT
	LDA	#$3F
	STA	SCBUF,X
	INX
	LDA	#$00
	STA	SCBUF,X
	INX
	LDA	#16
	STA	SCBUF,X		;QUE UP WRITE LOCATION AND COUNT
	INX
	STA	TMP_NMI1	;AND MAKE A LOOP COUNT
	LDY	#0
DP10:	LDA	(BPAL_BASE),Y
	INY
	STA	SCBUF,X	
	INX
	DEC	TMP_NMI1
	BNE	DP10
	STX	SCCNT
	RTS

;INITIALIZING A NEW SPRITE PALETTE.

DP100: 	LDA	NEW_PAL
	BEQ	DP200
	LDA	#0
	STA	NEW_PAL		;RESET FLAG, BOTH ARE INITIALIZED NOW

	LDY	#0
	LDA	(SPAL_BASE),Y
	STA	SPAL_BLINK	;SET BLINK FOR BACKGROUND
	INY
	LDA	(SPAL_BASE),Y
	STA	SPAL_DEPTH	;SET DEPTH OF BLINK
	INY
	LDA	#1
	STA	SPAL_INDX	;WE BOOT WITH BLINK 0, SO NEXT IS 1
	LDA	(SPAL_BASE),Y
	STA	SPAL_FREQ	;SET FREQUENCY
	STA	SPAL_CNT	;AND SET TIMER COUNT
	
	CLC
	LDA	SPAL_BASE
	ADC	#3
	STA	SPAL_BASE
	LDA	SPAL_BASE+1
	ADC	#0
	STA	SPAL_BASE+1	;POINT BASE DIRECTLY TO DATA

	LDX	SCCNT		;GET SCREEN BUFFER COUNT
	LDA	#$3F
	STA	SCBUF,X
	INX
	LDA	#$11		;SKIP PAST THE LOWEST REG WHICH OVERLAPS WITH
	STA	SCBUF,X		;THE BACKGROUND COLOR AND WOULD MESS IT UP.
	INX
	LDA	#15
	STA	SCBUF,X		;QUE UP WRITE LOCATION AND COUNT
	INX
	STA	TMP_NMI1	;AND MAKE A LOOP COUNT
	LDY	#1

DP110:	LDA	(SPAL_BASE),Y
	INY
	STA	SCBUF,X	
	INX
	DEC	TMP_NMI1
	BNE	DP110
	STX	SCCNT
	RTS			;AND DONE INITIALIZING PALETTE

;NOT INITIALIZING.  SEE IF BACKGROUND PALETTE BLINKS.
		
DP200:	LDA	BPAL_BLINK
	BEQ	DP300
      	DEC	BPAL_CNT
	BNE	DP300		;IF IT BLINKS, TIME TO UPDATE PALETTE?
	LDA	BPAL_FREQ
	STA	BPAL_CNT	;IF SO, RELOAD COUNT

	LDA	BPAL_BLINK
	ASL	A
	ASL	A		;MAKE *4 NUMBER OF BYTES PER BLINK INFO
	STA	TMP_NMI1	;AND SAVE AS NUMBER OF BYTES TO WRITE OUT.
	TAX
	LDY	BPAL_INDX	;GET THE FRAME WE ARE DOING
	JSR	MUL		;MAKE OFFSET TO THE COLORS
	LDA	#16
	SEC
	SBC	TMP_NMI1	;MAKE POINTER TO FIRST BLINKING PALETTE
	STA	TMP_NMI2	;SAVE FOR LATER
	JSR	ADD_WORD 	;AND ADD DEPTH INTO THE BLINKING ARRAY
	STX	NMI_PTR
	STY	NMI_PTR+1
	LDA	BPAL_BASE
	CLC
	ADC	NMI_PTR
	STA	NMI_PTR
	LDA	BPAL_BASE+1
	ADC	NMI_PTR+1
	STA	NMI_PTR+1	;ADD BASE TO THE LOCATION WE WANT

	LDX	SCCNT		;POINT WITHIN BUFFER AT WHICH TO STORE
	LDA	#$3F
	STA	SCBUF,X
	INX
	LDA	TMP_NMI2	;GET FIRST PAL REG TO UPDATE
	STA	SCBUF,X
	INX
	LDA	TMP_NMI1	;GET COUNT
	STA	SCBUF,X
	INX

DP210:	LDA	(NMI_PTR),Y	;GET DATA
	STA	SCBUF,X		;PUT IN BUFFER FOR UPDATE NEXT PASS
	INY
	INX
	DEC	TMP_NMI1	;DO THE NUMBER WE CALCULATED
	BNE	DP210
	STX	SCCNT		;UPDATE COUNT FOR NEXT PASS
	
	INC	BPAL_INDX	;UPDATE FOR NEXT TIME
	LDA	BPAL_INDX
	CMP	BPAL_DEPTH 	;SEE IF WENT TOO HIGH
	BNE	DP300
	LDA	#0
	STA	BPAL_INDX	;IF TOO HIGH, GO BACK TO 0

;SEE IF SPRITE PALETTE BLINKS

DP300: 	LDA	SPAL_BLINK
	BEQ	DP400
      	DEC	SPAL_CNT
	BNE	DP400		;IF IT BLINKS, TIME TO UPDATE PALETTE?
	LDA	SPAL_FREQ
	STA	SPAL_CNT

	LDA	SPAL_BLINK
	ASL	A
	ASL	A		;MAKE *4 NUMBER OF BYTES PER BLINK INFO
	STA	TMP_NMI1	;AND SAVE AS NUMBER OF BYTES TO WRITE OUT.
	TAX
	LDY	SPAL_INDX	;GET THE FRAME WE ARE DOING
	JSR	MUL		;MAKE OFFSET TO THE COLORS
	LDA	#16
	SEC
	SBC	TMP_NMI1	;MAKE POINTER TO FIRST BLINKING PALETTE
	STA	TMP_NMI2	;SAVE FOR LATER
	JSR	ADD_WORD	;AND ADD DEPTH INTO THE BLINKING ARRAY
	STX	NMI_PTR
	STY	NMI_PTR+1
	LDA	SPAL_BASE
	CLC
	ADC	NMI_PTR
	STA	NMI_PTR
	LDA	SPAL_BASE+1
	ADC	NMI_PTR+1
	STA	NMI_PTR+1	;ADD BASE TO THE LOCATION WE WANT


	LDX	SCCNT		;POINT WITHIN BUFFER AT WHICH TO STORE
	LDA	#$3F
	STA	SCBUF,X
	INX
	LDA	TMP_NMI2	;GET FIRST PAL REG TO UPDATE
	CLC
	ADC	#$10		;SPRITE REGS ARE HERE
	STA	SCBUF,X
	INX
	LDA	TMP_NMI1	;GET COUNT
	STA	SCBUF,X
	INX

	LDY	#0		;SET RETRIEVE INDEX.  
DP310:	LDA	(NMI_PTR),Y	;GET DATA
	STA	SCBUF,X		;PUT IN BUFFER FOR UPDATE NEXT PASS
	INY
	INX
	DEC	TMP_NMI1	;DO THE NUMBER WE CALCULATED
	BNE	DP310
	STX	SCCNT		;UPDATE COUNT FOR NEXT PASS
	
	INC	SPAL_INDX	;UPDATE FOR NEXT TIME
	LDA	SPAL_INDX
	CMP	SPAL_DEPTH 	;SEE IF WENT TOO HIGH
	BNE	DP400
	LDA	#0
	STA	SPAL_INDX	;IF TOO HIGH, GO BACK TO 0

DP400:	RTS

;THIS ROUTINE WILL DO A SCROLL OF THE BACKGROUND THAT WAS STARTED WITH
;SCRLBACK.  IT SHOULD BE CALLED EVERY NMI AND IT WILL CHECK AND MAINTAIN
;ITS OWN FLAGS.

;IMPORTANT TECHNICAL NOTE:  BECAUSE THIS ROUTINE ONLY BUILDS DATA
;TO WRITE TO SCREEN AND DOES NOT ACTUALLY WRITE IT, IT CANNOT UPDATE
;THE SCREEN SCROLL REGISTERS UNTIL THE DATA HAS BEEN WRITTEN OUT.
;WHEN A NEW ROW OR COLUMN IS ADDED, THERE IS A SAFE (LOWEST POSSIBLE
;VALUE) POSITION WITHIN THE NEW ROW.  THIS ROUTINE MOVES THERE BUT
;DOES NOT UPDATE THE SCROLL REGISTER.  THEN THE NEXT PASS WILL MOVE
;TO THE CORRECT LOCATION AND UPDATE THE SCROLL REGISTER TOO.  ONE
;SIDE EFFECT IS THAT IF THE USER MOVES A LOT USING THE SCROLL FUNCTION
;INSTEAD OF INIT AS RECOMMENDED, THE SCREEN WILL HOLD UNTIL ALL SCROLL
;DATA IS UPDATED.

DOSCRL:	LDA	MOVEBACK
	BNE	DOS10
DOS5:	RTS			;IF FLAG NOT SET, NOTHING TO DO.

DOS10:	JSR	FIXSCROLL	;FIX THE USER'S SCROLL VARIABLES

;SEE IF WE NEED AN X SCROLL.  IF WE ARE ON PIXEL 0, A MOVEMENT EITHER
;DIRECTION NEEDS A NEW COLUMN.  OTHERWISE, THE DIFFERENCE MUST BE 8 OR 
;MORE PIXELS.

DOS20:	LDA	MOVEBACK
	AND	#1		;X SCROLL NEEDED?
	BEQ	DOS55		;IF NOT, SKIP TO Y LOGIC
	
	LDA	#8
	STA	SCRLDIF		;SET FOR LOCATION CORRECTION OF 8.

 	LDA	CURX 		;GET CURRENT POSITION
	SEC
	SBC	XBACK		;MAKE DIFFERENCE TO NEW DIRECTION
	TAY
	LDA	CURX+1
	SBC	XBACK+1
	BCC	DOS30

;WE HAVE TO LOWER OUR X LOCATION (SCROLL TO THE LEFT).  

DOS25:	BNE	DOS60		;IF HIGH DIFFERENCE NON-ZERO, IT IS A SCROLL
	TYA			;IF TOP BYTE 0, SEE IF LOW BYTE IS ZERO TOO
	BEQ	DOS50		;IF NO SCROLL NEEDED, RESET X SCROLL BIT
	CMP	#8		;SEE IF DIF 8 OR GREATER 
	BCS	DOS60		;ALWAYS SCROLL IF SO
	STA	SCRLDIF

;THE SCROLL DIFFERENCE IS LESS THAN 8.  ANYTIME WE HAVE TO PASS THROUGH 0
;TO GET TO THE DESTINATION WE NEED TO SCROLL.
	
	LDA	XBACK
	AND	#7
	STA	SUBSVAR1
	LDA	CURX
	AND	#7
	SEC
	SBC	SUBSVAR1	;SEE IF PASSED THROUGH 0
	BCS	DOS40
	JMP	DOS60		;IF WE DID, NEED NEW COL EVEN THOUGH <8

;WE HAVE TO INCREASE OUR X LOCATION (SCROLL TO THE RIGHT).

DOS30:	CMP	#$FF		;SEE IF HIGH BYTE WAS MORE THAN -1
	BEQ	DOS35
	JMP	DOS100		;IF SO, DIFFERENCE WAS MORE THAN 8

DOS35:	TYA			;GET BACK LOW BYTE OF DIFFERENCE
	CMP	#$F9		;SEE IF MORE THAN 8	
	BCC	DOS100		;IF SO, ALWAYS NEED SCROLL
	EOR	#$FF
	ADC	#0		;MAKE THE ACTUAL DIFFERENCE IF <8
	STA	SCRLDIF		;SET AS SCROLL CORRECTION AMOUNT

;THE SCROLL DIFFERENCE IS LESS THAN 8.  ANYTIME WE HAVE TO PASS THROUGH 0
;TO GET TO THE DESTINATION WE NEED TO SCROLL.
	
	LDA	CURX
	AND	#7
	STA	SUBSVAR1
	LDA	XBACK
	AND	#7
	SEC
	SBC	SUBSVAR1	;SEE IF PASSED THROUGH 0
	BCS	DOS40
	JMP	DOS100		;IF WE DID, NEED NEW COL EVEN THOUGH <8

;X DOES NOT NEED ANY NEW DATA COLUMNS.  JUST SET OUR SCROLL AS THE SAME

DOS40:	LDA	XBACK
	STA	CURX
	LDA	XBACK+1
	STA	CURX+1

;SCROLL CORRECTED WITHOUT ADDING NEW COLUMNS.  RESET THE NEED X SCROLL BIT.

DOS50:	LDA	MOVEBACK
	AND	#$FE		;TURN OFF X NEEDS SCROLLING BIT
	STA	MOVEBACK
DOS55:	JMP	DOS200		;AND OK TO DO A Y SCROLL.

;ITS A NEGATIVE SCROLL.  WE NEED TO ADD A COL TO THE LEFT OF THE SCREEN.

DOS60: 	JSR	GET_ROOM	;GET FREE SPACE
	CMP	#69
	BCS	DOS70
	RTS		;IF NOT ENOUGH TO SCROLL, FORGET IT THIS PASS

DOS70:	LDX	CURX
	LDY	CURX+1
	JSR	ADJ_BACK	;MAKE CURRENT STARTING COL
	DEX			;BACK UP 1 COLUMN
	TXA
	PHA			;SAVE A COPY OF NEW STARTING COL

	LDA	CURX
	SEC
	SBC	SCRLDIF
	STA	CURX
	LDA	CURX+1
	SBC	#0
	STA	CURX+1		;MOVE LEFT AMOUNT WE MADE EARLIER

	LDX	CURY
	LDY	CURY+1
	JSR	ADJ_BACK	;MAKE ROW TO START FROM
	TXA
	TAY			;NEED ROW HERE
	PLA
	TAX			;GET BACK COL WE MADE

;IFDEF( `PAGED', `
.ifdef  PAGED
	LDA	BACKBASE+1	;SEE IF IN SECOND PAGE
	BMI	DOS72
	LDA	#5
	STA	TESTIT
	JSR	CALL_COL2  	;IF IN SECOND PAGE, GET ROW FROM THERE.
	LDA	#0
	STA	TESTIT
	JMP	DOS150
.endif

DOS72:	JSR	BUILD_COL	;MAKE DATA FOR THIS COLUMN
	JMP	DOS150		;AND DONE FOR NOW.  NEXT NMI WILL FIX PIXELS.

;ITS A POSITIVE SCROLL.  WE NEED TO ADD A COL TO THE RIGHT OF THE SCREEN.
;WE'LL ADD THAT BEFORE WE MOVE THE SCROLL BECAUSE THE NUMBER OF
;CHARS ON SCREEN IS USUALLY 33 SINCE WE GET PART OF THE FIRST AND LAST.

DOS100:	JSR	GET_ROOM	;GET FREE SPACE
	CMP	#69
	BCS	DOS105
	RTS			;IF NOT ENOUGH TO SCROLL, FORGET IT THIS PASS

DOS105:	LDX	CURY
	LDY	CURY+1
	JSR	ADJ_BACK	;MAKE CURRENT DATA ROW
	TXA
	PHA

	LDX	CURX		;GET CURRENT LOCATION
	LDY	CURX+1
	JSR	ADJ_BACK	;MAKE INTO COLUMN #
	TXA	
	CLC
	ADC	#33		;POINT TO NEW COL TO WRITE OUT
	TAX
	PLA
	TAY			;GET BACK ROW

;IFDEF( `PAGED', `
.ifdef  PAGED
	LDA	BACKBASE+1	;SEE IF IN SECOND PAGE
	BMI	DOS110
	LDA	#6
	STA	TESTIT
	JSR	CALL_COL2  	;IF IN SECOND PAGE, GET ROW FROM THERE.
	LDA	#0
	STA	TESTIT
	JMP	DOS112
.endif

DOS110:	JSR	BUILD_COL	;MAKE DATA FOR THIS COL

DOS112:	LDA	CURX		;GET CURRENT LOCATION
	CLC
	ADC	SCRLDIF
	STA	CURX
	LDA	CURX+1
	ADC	#0
	STA	CURX+1

;WE DID HAVE TO DO A NEW COLUMN.  BUT THE DATA ISN'T WRITTEN OUT YET
;SO WE CAN'T UPDATE THE SCREEN SCROLL VALUES.  WE'LL SKIP TRYING TO
;DO Y BECAUSE Y MIGHT NEED ONLY PIXEL ADJUSTMENT AND WOULD UPDATE
;THE SCREEN SCROLL VALUES.

DOS150:	RTS

;TRY TO DO A Y SCROLL.

DOS200:	LDA	MOVEBACK
	AND	#2		;Y SCROLL NEEDED?
	BNE	DOS221
	JMP	DOS400		;IF NOT, DONE.
	
DOS221:	LDA	#8
	STA	SCRLDIF		;SET FOR LOCATION CORRECTION OF 8.

	LDA	CURY 		;GET CURRENT POSITION
	SEC
	SBC	YBACK		;MAKE DIFFERENCE TO NEW DIRECTION
	TAY
	LDA	CURY+1
	SBC	YBACK+1
	BCC	DOS230

;WE HAVE TO LOWER OUR Y LOCATION (SCROLL UP).  

DOS225:	BNE	DOS260		;IF HIGH DIFFERENCE NON-ZERO, IT IS A SCROLL
	TYA			;IF TOP BYTE 0, SEE IF LOW BYTE IS ZERO TOO
	BEQ	DOS250		;IF NO SCROLL NEEDED, RESET Y SCROLL BIT
	CMP	#8		;SEE IF DIF 8 OR GREATER 
	BCS	DOS260		;ALWAYS SCROLL IF SO
	STA	SCRLDIF		;IF LESS THAN 8, SET AS DIFFERENCE

;THE SCROLL DIFFERENCE IS LESS THAN 8.  ANYTIME WE HAVE TO PASS THROUGH 0
;TO GET TO THE DESTINATION WE NEED TO SCROLL.
	
	LDA	YBACK
	AND	#7
	STA	SUBSVAR1
	LDA	CURY
	AND	#7
	SEC
	SBC	SUBSVAR1	;SEE IF PASSED THROUGH 0
	BCS	DOS240
	JMP	DOS260		;IF WE DID, NEED NEW ROW EVEN THOUGH <8

;WE HAVE TO INCREASE OUR Y LOCATION (SCROLL DOWN).

DOS230:	CMP	#$FF		;SEE IF HIGH BYTE WAS MORE THAN -1
	BEQ	DOS235
	JMP	DOS300		;IF SO, DIFFERENCE WAS MORE THAN 8

DOS235:	TYA			;GET BACK LOW BYTE OF DIFFERENCE
	CMP	#$F9		;SEE IF MORE THAN 8	
	BCC	DOS300		;IF SO, ALWAYS NEED SCROLL
	EOR	#$FF
	ADC	#0		;MAKE ACTUAL DIFFERENCE IF LESS THAN 8
	STA	SCRLDIF

;THE SCROLL DIFFERENCE IS LESS THAN 8.  ANYTIME WE HAVE TO PASS THROUGH 0
;TO GET TO THE DESTINATION WE NEED TO SCROLL.
	
	LDA	CURY
	AND	#7
	STA	SUBSVAR1
	LDA	YBACK
	AND	#7
	SEC
	SBC	SUBSVAR1	;SEE IF PASSED THROUGH 0
	BCS	DOS240
	JMP	DOS300		;IF WE DID, NEED NEW COL EVEN THOUGH <8

;Y DOES NOT NEED ANY NEW DATA ROWS.  JUST SET OUR SCROLL AS THE SAME

DOS240:	LDA	YBACK
	STA	CURY
	LDA	YBACK+1
	STA	CURY+1

;SCROLL CORRECTED WITHOUT ADDING NEW ROWS.  RESET THE NEED Y SCROLL BIT.

DOS250:	LDA	MOVEBACK
	AND	#$FD		;TURN OFF Y NEEDS SCROLLING BIT
	STA	MOVEBACK
	JMP	DOS400		;AND DONE.

;ITS A NEGATIVE SCROLL.  WE NEED TO ADD A ROW ABOVE.

DOS260:	JSR	GET_ROOM	;GET FREE SPACE
	CMP	#53
	BCS	DOS270
	RTS	    		;IF CAN'T DO Y NOW, SKIP IT.

DOS270:	LDX	CURY
	LDY	CURY+1
	JSR	ADJ_BACK	;MAKE CURRENT STARTING ROW
	DEX			;BACK UP 1 ROW
	TXA
	PHA			;SAVE A COPY OF NEW STARTING ROW

	LDA	CURY
	SEC
	SBC	SCRLDIF
	STA	CURY
	LDA	CURY+1
	SBC	#0
	STA	CURY+1		;MOVE LEFT AMOUNT WE MADE EARLIER

	LDX	CURX
	LDY	CURX+1
	JSR	ADJ_BACK	;MAKE COL TO START FROM
	PLA
	TAY			;GET BACK ROW WE MADE

;IFDEF( `PAGED', `
.ifdef  PAGED
	LDA	BACKBASE+1	;SEE IF IN SECOND PAGE
	BMI	DOS272
	LDA	#7
	STA	TESTIT
	JSR	CALL_ROW2 	;IF IN SECOND PAGE, GET ROW FROM THERE.
	LDA	#0
	STA	TESTIT
	JMP	DOS400
.endif

DOS272:	JSR	BUILD_ROW	;GET DATA ROW INTO SCBUF. 
	JMP	DOS400		;AND DONE FOR NOW.  NEXT NMI WILL FIX PIXELS.

;ITS A POSITIVE SCROLL.  WE NEED TO ADD A ROW BELOW THE SCREEN.

DOS300:	JSR	GET_ROOM	;GET FREE SPACE
	CMP	#53
	BCS	DOS305
	RTS	    		;IF CAN'T DO Y NOW, SKIP IT.

DOS305:	LDX	CURX
	LDY	CURX+1
	JSR	ADJ_BACK	;MAKE CURRENT DATA COL
	TXA
	PHA

	LDX	CURY		;GET CURRENT LOCATION
	LDY	CURY+1
	JSR	ADJ_BACK	;MAKE INTO ROW #
	TXA	
	CLC
	ADC	#30		;POINT TO NEW ROW TO WRITE OUT
	TAY
	PLA
	TAX			;GET BACK COL


;IFDEF( `PAGED', `
.ifdef  PAGED
	LDA	BACKBASE+1	;SEE IF IN SECOND PAGE
	BMI	DOS310
	LDA	#8
	STA	TESTIT
	JSR	CALL_ROW2  	;IF IN SECOND PAGE, GET ROW FROM THERE.
	LDA	#0
	STA	TESTIT
	JMP	DOS315
.endif

DOS310:	JSR	BUILD_ROW	;GET DATA ROW INTO SCBUF. 
DOS315:	LDA	CURY		;GET CURRENT LOCATION
	CLC
	ADC	SCRLDIF
	STA	CURY
	LDA	CURY+1
	ADC	#0
	STA	CURY+1

;DONE WITH ANY SCROLLING WE CAN DO.  

DOS400:	RTS

;THIS ROUTINE WILL TAKE THE CURRENT WINDOW POINTER (CURX AND CURY) AND
;UPDATE THE SCROLL REGISTERS USED BY NMI.

MAKE_SCROLL:
	LDA	BACKVALID	;MAKE SURE THERE IS A BACKGROUND TO USE
	BEQ	MKS20
	LDA	REG2000
	AND	#$FE		;REMOVE OLD PAGE SELECT BIT
	STA	REG2000
	LDA	CURX+1
	AND	#1		;MAKE NEW ONE FROM BIT 9 OF X SCROLL
	ORA	REG2000
	STA	REG2000			
	LDA	CURX
	STA	XSCROLL		;AND USE THE ACTUAL SCROLL AS THE X SCROLL

	LDA	CURY
	STA	TMP_NMI1
	LDA	CURY+1
	STA	TMP_NMI2	;GET Y INTO PLACE WE CAN SUBTRACT
	
	SEC
MKS10:	LDA	TMP_NMI1
	STA	YSCROLL		;SAVE LAST VALID LOW BYTE VALUE
	SBC	#$F0		;Y WRAPS AT F0
	STA	TMP_NMI1
	LDA	TMP_NMI2
	SBC	#0
	STA	TMP_NMI2
	BCS	MKS10		;KEEP GOING UNTIL UNDERFLOW
 	LDA	YSCROLL
	CLC
	ADC	YADJ
	STA	YSCROLL
MKS20:	RTS			;AND KEEP VALUE BEFORE IT HAPPENED

;THIS ROUTINE WILL TAKE A VIRTUAL DATA ROW # WITHIN THE CURRENT BACKGROUND 
;IN Y AND A VIRTUAL STARTING DATA COLUMN # IN X AND WILL LOAD SCBUF WITH THE 
;DATA TO FILL THAT ROW ON SCREEN.  IT MAKES THE CORRECT INDEX INFO INTO
;THE VIRTUAL SCREEN AND ALSO PUTS THE CORRECT PALETTE DATA THERE TOO.
;OUR SCREEN WRAPS AROUND IN THE SAME MANNER FOR ALL BACKGROUNDS AND THUS
;THE X AND Y ROW ARE ALL THAT IS NEEDED TO DETERMINE WHERE THE DATA IS
;TO BE WRITTEN.

;THIS ROUTINE DOES NOT RANGE CHECK YOUR VALUES SO MAKE SURE THEY ARE OK.

;SCBUF MUST HAVE 53 BYTES OF AVAILABLE ROOM IF 1 BY 1 MODE.
;THIS ROUTINE WILL NOT CHECK THIS FOR YOU, YOU MUST MAKE SURE SCBUF
;CAN HOLD THE REQUIRED DATA.

BUILD_ROW:

	STY	TMP_NMI7	;SAVE THE ROW AND COL WE ARE DOING
	STX	TMP_NMI8

	LDX	BACKWIDE
	JSR	MUL		
	LDA	TMP_NMI8
	JSR	ADD_WORD	;MAKE EXACT POINTER TO THE DATA
	TXA
	CLC
	ADC	BACKBASE
	STA	NMI_PTR
	TYA
	ADC	BACKBASE+1
	STA	NMI_PTR+1	;POINT TO THE DATA WITH INDIRECT REG

;NMI_PTR POINTS TO DATA, TMP_NMI7 HAS DATA ROW, TMP_NMI8 HAS COL

	LDA	TMP_NMI7	;GET BACK ROW
	SEC
BR10:	STA	TMP_NMI5	;SAVE VALUE BEFORE SUBTRACTING
	SBC	#30		;MOD IT BY THE ROW TO SEE WHERE IN SCREEN BUF
	BCS	BR10		;GO TILL UNDERFLOW.  THEN TMP_NMI5 HAS MOD ROW

	LDA	TMP_NMI8
	AND	#$1F		;MAKE SCREEN COLUMN MOD WIDTH
	STA	TMP_NMI6	

;NOW TMP_NMI5 HAS STARTING ROW WITHIN SCREEN BUFFER AND TMP_NMI6 HAS COL

BR15:	LDX	#$20		;ASSUME PAGE AT 2000H STARTS THE COLUMN
	
	LDA	#32
	AND	TMP_NMI8	;TEST TO GET PAGE NUMBER 
	BEQ	BR20
	LDX	#$24		;IF ODD BIT ABOVE WIDTH, PAGE 2

BR20:	STX	TMP_NMIA	;SAVE STARTING PAGE

;NOW TMP_NMIA HAS THE BASE PAGE HIGH BYTE

	LDX	TMP_NMI5	;GET BACK STARTING ROW
	LDY	#$20
	JSR	MUL		;MAKE BYTE OFFSET TO ROW START
	STX	TMP_NMID
	STY	TMP_NMIE	;SAVE OFFSET TO ROW START
	LDA	TMP_NMI6
	JSR	ADD_WORD	;POINT TO SCREEN OFFSET
	STX	TMP_NMI2
	TYA
	CLC
	ADC	TMP_NMIA	;ADJUST HIGH BYTE FOR PAGE OFFSET IN VIDEO
	STA	TMP_NMI3	;SAVE AS POINTER

	LDA	TMP_NMIA	
	EOR	#4		;MAKE HIGH BYTE OF NEXT PAGE
	CLC
	ADC	TMP_NMIE	;MAKE HIGH BYTE OF NEXT PAGE ADJUSTED TO ROW
	STA	TMP_NMIE

;NOW TMP_NMI2 AND 3 POINT TO THE SCREEN POSITION TO WRITE DATA AT.  IF
;THE LINE GOES INTO THE NEXT PAGE, TMP_NMID AND E HAVE THE ADDRESS.
;LOAD THAT DATA INTO SCBUF BUT WE MAY NEED TO BREAK UP
;THE LINE (HALF GETS ADDRESSED INTO 1 PAGE AND THE OTHER HALF GOES TO
;THE NEXT PAGE.

	LDX	SCCNT		;GET THE INDEX
	LDA	TMP_NMI3
	STA	SCBUF,X
	INX
	LDA	TMP_NMI2
	STA	SCBUF,X
	INX

	LDA	#32
	SEC			;SCROLL SITUATIONS (SPANS 33 CHARS, NOT 32).
	SBC	TMP_NMI6	;MAKE WIDTH TO END OF THIS SCREEN
	STA	TMP_NMI1

;WE ALREADY QUED PLACE TO WRITE TO.  NEED TO QUE AMOUNT TO WRITE OUT

	LDA	TMP_NMI1
	STA	SCBUF,X
	INX

;NOW QUE THE FIRST HALF OF THE DATA.  ACTUALLY, IT MAY ALL BE ON THIS
;SCREEN IF THE COLUMN IS 0.

	LDY	#0
BR40:	LDA	(NMI_PTR),Y	;GET A BYTE
	STA	SCBUF,X		;QUE IT UP
	INX
	INY
	DEC	TMP_NMI1
	BNE	BR40		

;SEE IF WE NEED TO WRITE OUT ANOTHER LINE.

	LDA	BACKWIDE	;GET WIDTH IN SCREEN
	SEC
	SBC	TMP_NMI8	;MAKE WIDTH LEFT TO END OF SCREEN
	CMP	#32		;SEE IF EXACTLY AT END
	BEQ	BR42
	INC	TMP_NMI1	;IF NOT, ALWAYS WRITE OUT EXTRA COL
BR42:	LDA	TMP_NMI6	;GET BACK COLUMN WITHIN SCREEN. 
	CLC
	ADC	TMP_NMI1	;ADD IN POSSIBLE EXTRA COLUMN
	STA	TMP_NMI1	;SAVE LENGTH TO WRITE
	BEQ	BR200		;IF NONE TO WRITE OUT, DON'T NEED THIS WRITE
	
	LDA	TMP_NMIE	;IF NEED SECOND WRITE, THIS HAS ADDRESS
	STA	SCBUF,X
	INX
	LDA	TMP_NMID
	STA	SCBUF,X
	INX
	LDA	TMP_NMI1	;AND THIS HAS LENGTH
	STA	SCBUF,X
	INX

BR60:	LDA	(NMI_PTR),Y	;GET A BYTE
	STA	SCBUF,X		;QUE IT UP
	INX
	INY
	DEC	TMP_NMI1
	BNE	BR60		

;DONE QUEING DATA.  QUE THE PALETTE INFO

BR200: 	STX	SCCNT		;SAVE OFFSET IN BUFFER
	LDA	TMP_NMI7	;GET ROW WITHIN ACTUAL SCREEN
	LSR	A
	LSR	A		;MAKE PALETTE ROW WE ARE ON
	TAY
	LDX	BPWIDE		;AND GET WIDTH OF PALETTE INFO
	JSR	MUL		
	LDA	TMP_NMI8	;GET COL WE ARE ON
	LSR	A
	LSR	A		;MAKE PALETTE BYTE IN THAT COLUMN WE ARE ON
	JSR	ADD_WORD	;MAKE EXACT POINTER TO THE DATA
	TXA
	CLC
	ADC	BPBASE
	STA	NMI_PTR
	TYA
	ADC	BPBASE+1
	STA	NMI_PTR+1	;POINT TO THE DATA WITH INDIRECT REG

;NMI_PTR POINTS TO PAL DATA WE ARE TO USE.  MAKE POINTERS TO THE
;PALETTE BYTE IN THE PALETTE RAM.

	LDA	TMP_NMI5	;GET BACK ROW WITHIN SCREEN
	LSR	A
	LSR	A
	STA	TMP_NMIB

	LDA	TMP_NMI6	;GET BACK COL WITHIN SCREEN
	LSR	A
	LSR	A		;AND MAKE INTO PALETTE BYTE
	STA	TMP_NMIC

;NOW TMP_NMIB HAS STARTING ROW WITHIN PALETTE BUFFER AND TMP_NMIC HAS BYTE

BR215:	LDX	#$23		;ASSUME PAGE 1 PALETTE ADDRESS
	
	LDA	#32
	AND	TMP_NMI8	;TEST TO GET PAGE NUMBER 
	BEQ	BR220
	LDX	#$27		;IF ODD BIT ABOVE WIDTH, PAGE 2

BR220:	STX	TMP_NMIA	;SAVE STARTING PAGE

;NOW TMP_NMIA HAS THE BASE PAGE HIGH BYTE

	LDX	TMP_NMIB	;GET BACK STARTING ROW
	LDY	#8
	JSR	MUL		;MAKE BYTE OFFSET TO ROW START
	STX	TMP_NMI3
	STY	TMP_NMI4	;SAVE COPY FOR NEXT PAGE POSSIBILITY
	LDA	TMP_NMIC
	JSR	ADD_WORD	;POINT TO SCREEN OFFSET
	TXA
	CLC
	ADC	#$C0		;LOW BYTE OF OFFSET IS C0
	STA	TMP_NMI1
	TYA
	ADC	TMP_NMIA	;ADJUST HIGH BYTE FOR PAGE OFFSET IN VIDEO
	STA	TMP_NMI2	;SAVE AS POINTER

	LDA	TMP_NMI3	;GET BACK SECOND PAGE POINTER
	CLC
	ADC	#$C0		;AND ADD THE START OF PAL RAM TOO
	STA	TMP_NMI3
	LDA	TMP_NMIA
	EOR	#4		;MAKE HIGH BYTE OF NEXT PAGE
	ADC	TMP_NMI4	;ADD IN HIGH BYTE OF OFFSET
	STA	TMP_NMI4

;NOW TMP_NMI1 AND 2 POINT TO THE SCREEN POSITION TO WRITE DATA AT.  IF
;THE LINE GOES INTO THE NEXT PAGE, TMP_NMI3 AND TMP_NMI4 HAVE THE LOCATION
;TO WRITE TO.  NOW LOAD THE PAL INTO SCBUF BUT WE MAY NEED TO BREAK UP
;THE LINE (HALF GETS ADDRESSED INTO 1 PAGE AND THE OTHER HALF GOES TO
;THE NEXT PAGE).

	LDX	SCCNT		;GET THE INDEX
	LDA	TMP_NMI2
	STA	SCBUF,X
	INX
	LDA	TMP_NMI1
	STA	SCBUF,X
	INX

	LDA	TMP_NMI6	;GET COL WITHIN THIS SCREEN
	TAY			;SAVE A COPY
	LSR	A
	LSR	A		;MAKE COLUMN TO START ON
	STA	TMP_NMI6

	LDA	BPWIDE		;GET SCREEN PALETTE WIDTH
	SEC
	SBC	TMP_NMIC	;MAKE PALETTE WIDTH TO END OF SCREEN
	CMP	#9		;SEE IF HAVE AT LEAST 9 LEFT TO WRITE OUT
	BCC	BR225		;IF NOT, WRITE WHAT WE CAN
      	LDA	#9		;IF SO, SET TO WRITE 9 FOR ODD PIX ALIGNMENT

BR225:	TAY			;SAVE WIDTH LEFT TO END OF BACKGROUND
	LDA	#8		
	SEC
	SBC	TMP_NMI6	;MAKE WIDTH TO END OF THIS PAGE
	STA	TMP_NMI1
	TYA			;GET WIDTH TO END OF PAL DATA OR 9 IF TOO BIG
	SEC
	SBC	TMP_NMI1	;MAKE AMOUNT FOR NEXT LINE
	STA	TMP_NMI6

;WE ALREADY QUED PLACE TO WRITE TO.  NEED TO QUE AMOUNT TO WRITE OUT.
;TMP_NMI1 HAS THAT.  TMP_NMI6 HAS AMOUNT FOR NEXT PAGE.

BR230:	LDA	TMP_NMI1
	STA	SCBUF,X
	INX

;NOW QUE THE FIRST HALF OF THE DATA.  ACTUALLY, IT MAY ALL BE ON THIS
;SCREEN IF THE COLUMN IS 0.

	LDY	#0
BR240:	LDA	(NMI_PTR),Y	;GET A BYTE
	STA	SCBUF,X		;QUE IT UP
	INX
	INY
	DEC	TMP_NMI1
	BNE	BR240		

;SEE IF WE NEED TO WRITE OUT ANOTHER PAL ROW

	LDA	TMP_NMI6	;GET BACK COLUMN WITHIN SCREEN. 
	BEQ	BR280		;ITS THE AMOUNT WE NEED ON SECOND SCREEN

	LDA	TMP_NMI4	;IF NEED SECOND WRITE, THIS HAS ADDRESS
	STA	SCBUF,X
	INX
	LDA	TMP_NMI3
	STA	SCBUF,X
	INX
	LDA	TMP_NMI6	;AND THIS HAS LENGTH
	STA	SCBUF,X
	INX

BR260:	LDA	(NMI_PTR),Y	;GET A BYTE
	STA	SCBUF,X		;QUE IT UP
	INX
	INY
	DEC	TMP_NMI6
	BNE	BR260		

BR280:	STX	SCCNT		;UPDATE COUNT IN BUFFER.

;ALL DONE.  

BR300: 	RTS

;THIS ROUTINE WILL TAKE A VIRTUAL DATA ROW # WITHIN THE CURRENT BACKGROUND 
;IN Y AND A VIRTUAL STARTING DATA COLUMN # IN X AND WILL LOAD SCBUF WITH THE 
;DATA TO FILL THAT COLUMN ON SCREEN.  IT MAKES THE CORRECT INDEX INFO INTO
;THE VIRTUAL SCREEN AND ALSO PUTS THE CORRECT PALETTE DATA THERE TOO.
;OUR SCREEN WRAPS AROUND IN THE SAME MANNER FOR ALL BACKGROUNDS AND THUS
;THE X AND Y ROW ARE ALL THAT IS NEEDED TO DETERMINE WHERE THE DATA IS
;TO BE WRITTEN.

;THIS ROUTINE DOES NOT RANGE CHECK YOUR VALUES SO MAKE SURE THEY ARE OK.

;SCBUF MUST HAVE 69 BYTES OF AVAILABLE ROOM IN THE SCREEN BUFFER.
;THIS ROUTINE WILL NOT CHECK THIS FOR YOU.

BUILD_COL:

	STX	TMP_NMI8
	STY	TMP_NMI7	;SAVE THE ROW AND COL WE ARE DOING

	LDX	BACKWIDE
	JSR	MUL		
	LDA	TMP_NMI8
	JSR	ADD_WORD	;MAKE EXACT POINTER TO THE DATA
	TXA
	CLC
	ADC	BACKBASE
	STA	NMI_PTR
	TYA
	ADC	BACKBASE+1
	STA	NMI_PTR+1	;POINT TO THE DATA WITH INDIRECT REG

;NMI_PTR POINTS TO DATA, TMP_NMI7 HAS DATA ROW, TMP_NMI8 HAS COL

	LDA	TMP_NMI7	;GET BACK ROW
	SEC
BC10:	STA	TMP_NMI5	;SAVE VALUE BEFORE SUBTRACTING
	SBC	#30		;MOD IT BY THE ROW TO SEE WHERE IN SCREEN BUF
	BCS	BC10		;GO TILL UNDERFLOW.  THEN TMP_NMI5 HAS MOD ROW

	LDA	TMP_NMI8
	AND	#$1F		;MAKE SCREEN COLUMN MOD WIDTH
	STA	TMP_NMI6	

;NOW TMP_NMI5 HAS STARTING ROW WITHIN SCREEN BUFFER AND TMP_NMI6 HAS COL

BC15:	LDX	#$20		;ASSUME PAGE AT 2000H STARTS THE COLUMN
	
	LDA	#32
	AND	TMP_NMI8	;TEST TO GET PAGE NUMBER 
	BEQ	BC20
	LDX	#$24		;IF ODD BIT ABOVE WIDTH, PAGE 2

BC20:	STX	TMP_NMIA	;SAVE STARTING PAGE

;NOW TMP_NMIA HAS THE BASE PAGE HIGH BYTE

	LDX	TMP_NMI5	;GET BACK STARTING ROW
	LDY	#$20
	JSR	MUL		;MAKE BYTE OFFSET TO ROW START
	LDA	TMP_NMI6
	JSR	ADD_WORD	;POINT TO SCREEN OFFSET
	STX	TMP_NMI2
	TYA
	CLC
	ADC	TMP_NMIA	;ADJUST HIGH BYTE FOR PAGE OFFSET IN VIDEO
	STA	TMP_NMI3	;SAVE AS POINTER

;NOW TMP_NMI2 AND 3 POINT TO THE SCREEN POSITION TO WRITE DATA AT.  IF
;THE LINE GOES INTO THE NEXT PAGE, TMP_NMI6 HAS THE COLUMN TO START AT AND
;TMP_NMIA IS THE PAGE (SAME PAGE). LOAD THE DATA INTO SCBUF BUT WE MAY 
;NEED TO BREAK UP THE LINE (HALF GETS ADDRESSED INTO 1 PAGE AND THE 
;OTHER HALF GOES TO THE NEXT PAGE.

	LDX	SCCNT		;GET THE INDEX
	LDA	TMP_NMI3
	ORA	#$80		;SET VERTICAL WRITE BIT
	STA	SCBUF,X
	INX
	LDA	TMP_NMI2
	STA	SCBUF,X
	INX

	LDA	#30		;GET MAX HEIGHT WE CAN WRITE
	CMP	BACKHIGH	;SEE IF THERE REALLY IS THAT MUCH
	BCC	BC30
     	LDA	BACKHIGH	;IF NOT, WRITE OUT MAX
BC30:	SEC
	SBC	TMP_NMI5	;MAKE HEIGHT TO BOTTOM OF THIS SCREEN
	STA	TMP_NMI1

;WE ALREADY QUED PLACE TO WRITE TO.  NEED TO QUE AMOUNT TO WRITE OUT

	STA	SCBUF,X
	INX

;NOW QUE THE FIRST HALF OF THE DATA.  ACTUALLY, IT MAY ALL BE ON THIS
;SCREEN IF THE ROW IS 0.

	LDY	#0
	CLC
BC40:	LDA	(NMI_PTR),Y	;GET A BYTE
	STA	SCBUF,X		;QUE IT UP
	INX			;SKIP IN SCREEN BUFFER
	TYA
	ADC	BACKWIDE	;SKIP TO NEXT ROW IN DATA
	TAY
	BCC	BC45
	INC	NMI_PTR+1
	CLC
BC45:	DEC	TMP_NMI1
	BNE	BC40		

;SEE IF WE NEED TO WRITE OUT ANOTHER LINE.

	LDA	TMP_NMI5	;GET BACK ROW WITHIN SCREEN. 
	BEQ	BC200		;ITS THE AMOUNT WE NEED ON SECOND SCREEN

	LDA	TMP_NMIA	;IF NEED SECOND WRITE, START AT SCREEN TOP
	ORA	#$80		;OF SAME PAGE
	STA	SCBUF,X
	INX
	LDA	TMP_NMI6	;GET COLUMN WITHIN THAT ROW
	STA	SCBUF,X
	INX
	LDA	TMP_NMI5	;AND THIS HAS LENGTH
	STA	SCBUF,X
	INX
	STA	TMP_NMI1	;PUT BACK FOR LOOP COUNTER

	CLC
BC60:	LDA	(NMI_PTR),Y	;GET A BYTE
	STA	SCBUF,X		;QUE IT UP
	INX
	TYA
	ADC	BACKWIDE	;SKIP TO NEXT ROW IN DATA
	TAY
	BCC	BC65
	INC	NMI_PTR+1
	CLC
BC65:	DEC	TMP_NMI1
	BNE	BC60		

;DONE QUEING DATA.  QUE THE PALETTE INFO

BC200: 	STX	SCCNT		;SAVE OFFSET IN BUFFER
	LDA	TMP_NMI7	;GET ROW WITHIN ACTUAL SCREEN
	LSR	A
	LSR	A		;MAKE PALETTE ROW WE ARE ON
	TAY
	LDX	BPWIDE		;AND GET WIDTH OF PALETTE INFO
	JSR	MUL		
	LDA	TMP_NMI8	;GET COL WE ARE ON
	LSR	A
	LSR	A		;MAKE PALETTE BYTE IN THAT COLUMN WE ARE ON
	JSR	ADD_WORD	;MAKE EXACT POINTER TO THE DATA
	TXA
	CLC
	ADC	BPBASE
	STA	NMI_PTR
	TYA
	ADC	BPBASE+1
	STA	NMI_PTR+1	;POINT TO THE DATA WITH INDIRECT REG

;NMI_PTR POINTS TO PAL DATA WE ARE TO USE.  MAKE POINTERS TO THE
;PALETTE BYTE IN THE PALETTE RAM.

	LDA	TMP_NMI5	;GET BACK ROW WITHIN SCREEN
	LSR	A
	LSR	A
	STA	TMP_NMIB

	LDA	TMP_NMI6	;GET BACK COL WITHIN SCREEN
	LSR	A
	LSR	A		;AND MAKE INTO PALETTE BYTE
	STA	TMP_NMIC

;NOW TMP_NMIB HAS STARTING ROW WITHIN PALETTE BUFFER AND TMP_NMIC HAS BYTE

BC215:	LDX	#$23		;ASSUME PAGE 1 PALETTE ADDRESS
	
	LDA	#32
	AND	TMP_NMI8	;TEST TO GET PAGE NUMBER 
	BEQ	BC220
	LDX	#$27		;IF ODD BIT ABOVE WIDTH, PAGE 2

BC220:	STX	TMP_NMIA	;SAVE STARTING PAGE

;NOW TMP_NMIA HAS THE BASE PAGE HIGH BYTE

	LDX	TMP_NMIB	;GET BACK STARTING ROW
	LDY	#8
	JSR	MUL		;MAKE BYTE OFFSET TO ROW START
	STX	TMP_NMI3
	STY	TMP_NMI4	;SAVE COPY FOR NEXT PAGE POSSIBILITY
	LDA	TMP_NMIC
	JSR	ADD_WORD	;POINT TO SCREEN OFFSET
	TXA
	CLC
	ADC	#$C0		;LOW BYTE OF OFFSET IS C0
	STA	TMP_NMI1
	TYA
	ADC	TMP_NMIA	;ADJUST HIGH BYTE FOR PAGE OFFSET IN VIDEO
	STA	TMP_NMI2	;SAVE AS POINTER

;NOW TMP_NMI1 AND 2 POINT TO THE PAL RAM POSITION TO WRITE DATA AT.  
;NOW LOAD THE PAL INTO SCBUF BUT WE NEED TO BREAK UP DATA INTO INDIVIDUAL
;BYTES EACH ADDRESSED SEPERATELY.

	LDA	BACKHIGH
	CLC
	ADC	#3		;ROUND UP HEIGHT IN ROWS
	LSR	A
	LSR	A		;MAKE HEIGHT IN PALETTE BYTES
	STA	TMP_NMI3	;SAVE HERE	
	LDA	#8		;GET HEIGHT IF FULL SCREEN.
	CMP	TMP_NMI3	;SEE IF WE CAN DO IT
	BCC	BC225		;IF THERE ARE ENOUGH, OK
	LDA	TMP_NMI3
BC225:	STA	TMP_NMI3
	LDX	SCCNT		;GET THE INDEX
	LDY	#0		;ZERO INDEX WITHIN PALLETE RAM.

;START OF LOOP TO INDIVIDUALLY ADDRESS AND WRITE UP TO 8 PALETTE BYTES.

BC230:	LDA	TMP_NMI2
	STA	SCBUF,X
	INX
	LDA	TMP_NMI1
	STA	SCBUF,X
	INX
	LDA	#1		;WE ALWAYS JUST QUE 1 IN THIS CASE
	STA	SCBUF,X
	INX

	LDA	(NMI_PTR),Y	;GET THE BYTE
	STA	SCBUF,X		;QUE IT UP
	INX
	TYA
	CLC
	ADC	BPWIDE		;UPDATE INDEX WITHIN OUR DATA
	TAY
	BCC	BC240
	INC	NMI_PTR+1

;WRAP THE PALETTE RAM INDEX.  WE JUST NEED TO WRAP AROUND IN THIS BUFFER.

BC240:	LDA	TMP_NMI1
	CLC
	ADC	#8		;SKIP TO NEXT PALETTE ROW
	ORA	#$C0		;BUT IF GOES PAST 0, MOVE BACK TO START
	STA	TMP_NMI1

	DEC	TMP_NMI3
	BNE	BC230		

	STX	SCCNT		;UPDATE COUNT IN BUFFER

;ALL DONE. 

BC300: 	RTS

;THIS ROUTINE WILL RETURN THE AMOUNT OF FREE SPACE IN SCBUF.  IT IS
;RETURNED IN A.  ONLY A IS CHANGED.

GET_ROOM:
	LDA	#SCSIZE
	SEC
	SBC	SCCNT
	RTS

;THIS ROUTINE WILL FIX XBACK AND YBACK TO KEEP THEM IN RANGE WITH THE
;CURRENTLY SPECIFIED BACKGROUND.  IT ALSO RETURNS THE Y DATA ROW AND
;X DATA COL OF THE CORRECTED SCROLL POSITIONS IN TMP_NMI7 AND TMP_NMI8
;RESPECTIVELY.  IT ASSUMES THAT INITBACK HAS ALREADY SET CERTAIN
;BACKGROUND VARIABLES.

FIXSCROLL:

	LDY	XBACK+1
	LDX	XBACK
	TYA			;GET HIGH BYTE OF X LOCATION
	BPL	FX5
    	LDX	#0
	LDY	#0
	STX	XBACK
	STY	XBACK+1		;IF WENT NEGATIVE, GO TO START.

FX5:	JSR	ADJ_BACK	;MAKE X DATA COL DESIRED BY USER
	STX	TMP_NMI8

	LDY	YBACK+1
	LDX	YBACK
	TYA
	BPL	FX7
    	LDX	#0
	LDY	#0
	STX	YBACK
	STY	YBACK+1		;IF WENT NEGATIVE, GO TO START.

FX7:	JSR	ADJ_BACK	;MAKE Y DATA ROW DESIRED BY USER
	STX	TMP_NMI7

	LDA	END_COL		;GET LAST LEGAL DATA COLUMN
	CMP	TMP_NMI8	;SEE IF OUR VALUE IS OK
	BNE	FX10

	LDA	XBACK
	AND	#$F8
	STA	XBACK		;IF EXACTLY AT END, NO ODD PIXELS ALLOWED
	JMP	FX20

FX10:	BCS	FX20
	LDX	END_COL
	STX	TMP_NMI8
	LDY	#0
	JSR	BACK_PIX
	STX	XBACK
	STY	XBACK+1		;IF PAST END, MOVE BACK TO LAST LEGAL POS.

FX20:	LDA	END_ROW		;GET LAST LEGAL DATA ROW
	CMP	TMP_NMI7	;SEE IF OUR Y VALUE IS OK
	BNE	FX30

	LDA	YBACK
	AND	#$F8
	STA	YBACK		;IF EXACTLY AT END, NO ODD PIXELS ALLOWED
	JMP	FX40

FX30:	BCS	FX40
	LDX	END_ROW
	STX	TMP_NMI7
	LDY	#0
	JSR	BACK_PIX
	STX	YBACK
	STY	YBACK+1		;IF PAST END, MOVE BACK TO LAST LEGAL POS.

FX40:	RTS


;THIS ROUTINE WILL TAKE A VALID PIXEL COLUMN OR ROW LOCATION IN Y:X AND MAKE 
;IT INTO AN ACTUAL DATA COLUMN OR ROW POINTER WITHIN A BACKGROUND.  
;IT SHIFTS THE VALUE DOWN.

ADJ_BACK:
	JSR	SHIFTDOWN
	JSR	SHIFTDOWN
	JSR	SHIFTDOWN
	RTS

;THIS ROUTINE WILL TAKE A DATA ROW OR COLUMN POSITION IN Y:X AND
;MAKE IT INTO AN ACTUAL PIXEL ROW OR COLUMN LOCATION WITHIN A BACKGROUND.
;IT SHIFTS UP ACCOUNTING FOR BACKGROUND SIZE.

BACK_PIX:
	JSR	SHIFTUP
	JSR	SHIFTUP
	JSR	SHIFTUP
	RTS

;THIS SUBROUTINE WILL SHIFT A WORD VALUE IN Y:X DOWN 1 BIT.

SHIFTDOWN:
	TYA
	LSR	A
	TAY
	TXA
	ROR	A
	TAX
	RTS

;THIS SUBROUTINE WILL SHIFT A WORD VALUE IN Y:X UP 1 BIT.

SHIFTUP:	
	TXA
	ASL	A
	TAX
	TYA
	ROL	A
	TAY
	RTS

;THIS ROUTINE WILL MULTIPLY REGISTER X BY REGISTER Y AND STORE THE RESULT
;LOW BYTE IN X AND HIGH IN Y.  THIS ROUTINE MAY BE CALLED FROM
;ANY LEVEL AND IT USES ITS OWN VARIABLES.  THIS ROUTINE DOES NOT CHANGE
;MATH4.

MUL: 	STY	MATH1		;SAVE MULTIPLIER
	STX	MATH3		;SAVE MULTIPLICAND
	LDA	#0
	STA	MATH2		;ZERO HIGH RESULT
	LDX	#8		;THERE ARE 8 BITS TO TEST FOR

M10:	ASL	A		;SHIFT PRODUCT 1 TO DOUBLE IT.  FIRST LOOP=0
	ROL	MATH2		;AND MOVE BIT UP INTO RESULT HIGH BYTE

	ASL	MATH1		;SEE IF WE NEED TO ADD FOR THIS BIT
	BCC	M20
	CLC
	ADC	MATH3		;IF SO, ADD IN THE VALUE
	BCC	M20
	INC	MATH2		;IF CARRY, BRING UP TO HIGH RESULT
M20:	DEX
	BNE	M10
	TAX			;SAVE LOW BYTE IN RETURN REG	
	LDY	MATH2		;AND GET HIGH
	RTS

;THIS ROUTINE WILL DIVIDE THE 1 WORD VALUE IN Y:X BY THE 1 BYTE VALUE IN 
;A.  THE RESULT IS STORED IN X WITH THE REMAINDER IN Y.  THE 1 WORD
;VALUE MUST BE LESS THAN 8000H AND THE RESULT MUST FIT INTO 1 BYTE.

DIVIDE:	STX	MATH1
	STY	MATH2		;SAVE DIVIDEND
	STA	MATH3		;SAVE DIVISOR
	STX	MATH4		;SAVE COPY OF LOW DIVIDEND IN WORKING REG
	TYA			;GET HIGH	
	LDX	#8		;MAKE LOOP COUNT
D10:	ASL	MATH4		;SHIFT UP LOW TO SEE IF WE CAN SUBTRACT
	ROL	A
	CMP	MATH3
	BCC	D20
	SBC	MATH3
	INC	MATH4
D20:	DEX
	BNE	D10
	TAY			;PUT REMAINDER IN Y
	LDX	MATH4		;AND GET RESULT
	RTS

;THIS ROUTINE WILL ADD THE 1 BYTE VALUE IN A TO THE 2 BYTE VALUE IN
;X AND Y (X LOW BYTE).  THIS ROUTINE MAY BE CALLED FROM ANY LEVEL AND 
;IT USES ITS OWN VARIABLES.  ONLY MATH1 IS CHANGED.

ADD_WORD:
	STX	MATH1
	CLC
	ADC	MATH1
	TAX
	BCC	AW10
	INY
AW10:	RTS

;THIS ROUTINE WILL NEGATE A.

NEGATE:
	EOR	#$FF
	CLC
	ADC	#1
	RTS

;THIS ROUTINE WILL TAKE ANY DATA IN SCBUF AND WRITE IT TO VIDEO. IT
;ASSUMES YOU HAVE ALREADY DISABLED VIDEO AND IT IS OK TO WRITE.  IT
;RESETS SCCNT WHEN DONE.  ITS OK FOR SCBUF TO BE EMPTY.

;THIS ROUTINE HONORS THE VERTICAL WRITE BIT BUT WILL ALWAYS RESET
;THIS WHEN DONE.  THE VERTICAL WRITE BIT IS IN REG $2000.

;THIS ROUTINE DOES NOT USE TMP_NMI2 OR ABOVE.

WRITE_SCBUF:

	LDY	#0		;IF DATA, WRITE FROM BUFFER START

W20:	LDA	SCCNT		
	BEQ	W100		;SKIP IF NO DATA IN SCREEN BUFFER TO WRITE
	SEC
	SBC	SCBUF+2,Y	;IF DATA LEFT, UPDATE AMOUNT AFTER THIS PASS
	SBC	#3
	STA	SCCNT		;AND PUT BACK FOR NEXT LOOP

  	LDA	REG2000		;GET VALUE FOR REG 2000
	AND	#$7A
	LDX	SCBUF,Y		;GET HIGH BYTE OF LOCATION
	BPL	W25
	ORA	#4		;IF BIT 80H SET IN LOCATION, NEED VERTICAL BIT
W25: 	STA	$2000
	TXA
	AND	#$7F 		;REMOVE VERTICAL WRITE BIT
	STA	$2006
	INY
	LDA	SCBUF,Y		;GET LOW
	STA	$2006		;AND USE BOTH TO SET UP THE INDEX REG
	INY
	LDX	SCBUF,Y		;GET THE LENGTH TO WRITE OUT
	INY			;POINT TO THE DATA TO WRITE
;This is located at $1E1F
W40:	LDA	SCBUF,Y
	INY
	STA	$2007		;WRITE OUT A DATA BYTE $1E23
	DEX
	BNE	W40
	JMP	W20	

W100:	LDA	REG2000
	STA	$2000		;REMOVE POSSIBLE VERTICAL WRITE BIT
 	RTS


;THIS ROUTINE WILL WAIT FOR THE NEXT VERTICAL RETRACE.  IT IS NOT
;CLEAR WHETHER IT WILL FUNCTION WITH NMI ENABLED SO DON'T CALL UNLESS
;NMI IS DISABLED.
;.org $9DFE		;Evenball
;But its actually at $1E33?????
VERT_WAIT:
	LDA	$2002
	BPL	VERT_WAIT
	RTS

;THIS ROUTINE WILL HIDE ALL SPRITES BY PUTTING THEM ON THE LAST SCAN
;LINE OF THE SCREEN. IT ALSO RESETS OUR SPRITE IN USE FLAG BIT. IT
;SHOULD BE CALLED ONLY AT BOOT TIME.

HIDESPRITES:
	LDY	#0
	LDX	#64

;CALL HERE WITH YOUR OWN Y STARTING INDEX AND X COUNT TO HIDE JUST 
;WHAT YOU WANT.

HIDE2:

;IFDEF( `GUNLOGIC', `
.ifdef  GUNLOGIC
	LDA	SPRITES_HIDDEN
	BEQ	HS10		;USE NORMAL LOOP IF NOT SCANNING GUN
	STX	TMP_NMI1
	TYA
	LSR	A
	LSR	A		;MAKE INDEX INTO SAVE SPRITES RAM
	TAX
GHS10: 	LDA	#0		;AND FREE UP THE SPRITE, RESET PALETTE BITS
	STA	SPRAM+2,Y
	LDA	#248
	STA	SAVE_SPRITES,X		;MOVE OFF SCREEN
	INY
	INY
	INY
	INY
	INX
	DEC	TMP_NMI1
	BNE	GHS10
	RTS
.endif

HS10:	LDA	#$F8
	STA	SPRAM,Y		;MOVE OFF SCREEN
	LDA	#0		;AND FREE UP THE SPRITE, RESET PALETTE BITS
	STA	SPRAM+2,Y
	INY
	INY
	INY
	INY
	DEX
	BNE	HS10
	RTS